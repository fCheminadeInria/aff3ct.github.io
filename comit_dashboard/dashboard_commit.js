importScripts("https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js");

function sendPatch(patch, buffers, msg_id) {
  self.postMessage({
    type: 'patch',
    patch: patch,
    buffers: buffers
  })
}

async function startApplication() {
  console.log("Loading pyodide!");
  self.postMessage({type: 'status', msg: 'Loading pyodide'})
  self.pyodide = await loadPyodide();
  self.pyodide.globals.set("sendPatch", sendPatch);
  console.log("Loaded!");
  await self.pyodide.loadPackage("micropip");
  const env_spec = ['https://cdn.holoviz.org/panel/wheels/bokeh-3.6.1-py3-none-any.whl', 'https://cdn.holoviz.org/panel/1.5.4/dist/wheels/panel-1.5.4-py3-none-any.whl', 'pyodide-http==0.2.1', 'matplotlib', 'pandas', 'param', 'plotly']
  for (const pkg of env_spec) {
    let pkg_name;
    if (pkg.endsWith('.whl')) {
      pkg_name = pkg.split('/').slice(-1)[0].split('-')[0]
    } else {
      pkg_name = pkg
    }
    self.postMessage({type: 'status', msg: `Installing ${pkg_name}`})
    try {
      await self.pyodide.runPythonAsync(`
        import micropip
        await micropip.install('${pkg}');
      `);
    } catch(e) {
      console.log(e)
      self.postMessage({
	type: 'status',
	msg: `Error while installing ${pkg_name}`
      });
    }
  }
  console.log("Packages loaded!");
  self.postMessage({type: 'status', msg: 'Executing code'})
  const code = `
  \nimport asyncio\n\nfrom panel.io.pyodide import init_doc, write_doc\n\ninit_doc()\n\nimport pandas as pd\nimport panel as pn\nfrom datetime import datetime\nimport sys\nimport os\nimport argparse\nimport re\nfrom pyodide.http import open_url\nimport matplotlib.pyplot as plt\n#import numpy as np\nimport plotly.graph_objs as go\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport param\nfrom panel.viewable import Viewer\nimport unicodedata as ud\n\nprint(ud.unidata_version)\n\n#from uncertainty_button import Panel_graph_envelope\n\n# Initialiser Panel\npn.extension("plotly", sizing_mode="stretch_width")  # Adapter la taille des widgets et graphiques \xe0 la largeur de l'\xe9cran\n\n# G\xe9n\xe9rer une palette de couleurs\ncolors = px.colors.qualitative.Plotly\n\n##################################### Component ####################################\n\nclass ConfigPanel(pn.viewable.Viewer) :\n        # Param\xe8tres configurables\n    df = param.DataFrame(doc="Le dataframe contenant les donn\xe9es \xe0 filtrer")\n    colors = param.Dict(default={},doc="Couleurs des courbes")\n    value = param.List(default=[],doc="Liste des index s\xe9lectionn\xe9es" )\n\n    def __init__(self, **params):\n        super().__init__(**params)\n\n        # self.config_filtered = config_df.index\n        config_options = self.df['Config_Alias'].unique().tolist() if not config_df.empty else []\n        self.config_selector = pn.widgets.MultiChoice(name="S\xe9lectionnez les configurations", options=config_options)\n\n        # S\xe9lecteur des configs\n        self.select_all_button = pn.widgets.Button(name="Tout s\xe9lectionner", button_type="success")\n        self.clear_button = pn.widgets.Button(name="Tout d\xe9s\xe9lectionner", button_type="warning")\n\n        self.select_all_button.on_click(self.select_all_configs)\n        self.clear_button.on_click(self.clear_configs)\n#        pn.bind(self._update_value, self.config_selector)\n        self.config_selector.param.watch(self._update_value, 'value')\n\n\n\n    def __panel__(self):\n        return pn.Column(\n            self.select_all_button, \n            self.clear_button, \n            self.config_selector, \n            Research_config_filter(config_selector = self.config_selector, df = self.df), \n            width=300)\n    \n    \n    def _update_value(self, event):\n        # Met \xe0 jour \`self.value\` en fonction des configurations s\xe9lectionn\xe9es\n        selected_configs = event.new\n        if len(selected_configs) !=0 :\n            self.value = self.df[ self.df["Config_Alias"].isin(selected_configs)].index.tolist()\n        else :\n            self.value = []\n            \n        # Met \xe0 jour les couleurs\n        for i, color in enumerate(px.colors.qualitative.Plotly[:len(self.value)]):\n            self.colors[self.value[i]] = color\n            \n    # Boutons d'agr\xe9gat\n    def select_all_configs(self, event=None):\n        self.config_selector.value = self.config_selector.options\n\n    def clear_configs(self, event=None):\n        self.config_selector.value = []\n\nclass NoiseScale (pn.viewable.Viewer) :\n    value = param.String(default= 'Signal Noise Ratio(SNR).Eb/N0(dB)', allow_refs=True)\n    noise_label = param.Dict()\n    \n    def __init__ (self, **params):\n        super().__init__(**params)\n        \n        self.radio_group = pn.widgets.RadioBoxGroup(\n            name='Echelle de bruit', \n            options=list(self.noise_label.keys()), \n            value=list(self.noise_label.keys())[0], \n            inline=True )\n        self._update_value(None)\n        self.radio_group.param.watch(self._update_value, "value")\n\n    def __panel__(self):\n        return pn.Column(\n            pn.pane.Markdown(f"**{self.radio_group.name} :** "),\n            pn.Row(self.radio_group, css_classes=["align-right"],sizing_mode="stretch_width"),\n            sizing_mode="stretch_width")\n\n    def _update_value(self, event):\n        """\n        Met \xe0 jour la propri\xe9t\xe9 \`value\` en fonction de la s\xe9lection.\n        """\n        self.value = self.noise_label[self.radio_group.value]\n\nclass Panel_graph_envelope(pn.viewable.Viewer):\n    # Param\xe8tres configurables\n    df = param.DataFrame(doc="Le dataframe contenant les donn\xe9es")\n    lab = param.String(default="y", doc="Nom de la colonne pour l'axe Y")\n    lab_group = param.String(default=None, doc="Nom de la colonne pour regrouper les donn\xe9es")\n    labmin = param.String(default=None, doc="Nom de la colonne pour la valeur minimale")\n    labmax = param.String(default=None, doc="Nom de la colonne pour la valeur maximale")\n    Ytitle = param.String(default="Valeur", doc="Titre de l'axe Y")\n    multi_choice_widget = param.ClassSelector(default=None, class_=pn.viewable.Viewer, doc="Panel de s\xe9lection des configurations")\n    noiseScale = param.ClassSelector(default=None, class_=pn.viewable.Viewer,doc="Choix de l'\xe9chelle de bruit par passage du label de la colonne")\n    #colors = param.ClassSelector(default=None, class_=pn.viewable.Viewer,doc="Couleurs des courbes")\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        \n        self.button_env = pn.widgets.Toggle(name='\u303d\ufe0f', value=True)\n        \n        if (self.labmin == None or self.labmax == None):\n            self.button_env.value=False\n            self.button_env.disabled=True\n        \n        self.ListBouton = pn.Column(\n            pn.widgets.TooltipIcon(value="Activer/D\xe9sactiver Enveloppe"), \n            self.button_env,\n            width=50)\n        self.graphPanel = pn.bind(self._plot_enveloppe_incertitude,self.button_env, self.multi_choice_widget.param.value, self.noiseScale.param.value)\n        \n\n    def __panel__(self):\n        return pn.Row(self.ListBouton, self.graphPanel)\n        \n    def _plot_enveloppe_incertitude(self, show_envelope, index, noiseKey):    \n     \n        if index is None :\n            df_filtred = self.df\n        else :\n            df_filtred = self.df.loc[index] \n        \n        # Si pas de donn\xe9es de t\xe2ches pour les configurations s\xe9lectionn\xe9es\n        if df_filtred.empty:\n            self.button_env.disabled=True\n            if self.lab_group :\n                return pn.pane.Markdown(f"Graphes de {self.Ytitle} : Pas de donn\xe9es de {self.lab_group} disponibles pour les configurations s\xe9lectionn\xe9es.")\n            else :\n                return pn.pane.Markdown(f"Graphes de {self.Ytitle} : Pas de donn\xe9es disponibles pour les configurations s\xe9lectionn\xe9es.")\n        else :\n            self.button_env.disabled=False\n            \n        if (self.labmin == None or self.labmax == None):\n            show_envelope = False\n        \n        # G\xe9n\xe9rer une palette de couleurs automatiquement selon le nombre de configurations\n        if self.lab_group : \n            colors = px.colors.qualitative.Plotly[:len(index) * len(df_filtred[self.lab_group].unique())]\n        else :\n            colors = px.colors.qualitative.Plotly[:len(index) * len(df_filtred.index.unique())]\n\n        fig = go.Figure()\n\n        # Ajouter une trace pour chaque configuration et t\xe2che\n        for i, config in enumerate(index):\n            # Filtrer les donn\xe9es pour chaque configuration\n            config_data = df_filtred.loc[config]\n            alias = config_df.loc[config, 'Config_Alias'] #variable global pas propre mais commode\n            if self.lab_group :\n                for j, t in enumerate(config_data[self.lab_group].unique()):  \n                    task_data = config_data[config_data[self.lab_group] == t]\n                    snr = task_data[noiseKey]\n                    y_values = task_data[self.lab]         \n                    \n                    \n                    if show_envelope :\n                        y_values_min = task_data[self.labmin]  \n                        y_values_max = task_data[self.labmax]   \n                        \n                        # Courbe pour la latence avec enveloppe\n                        fig.add_trace(go.Scatter(\n                            x=snr, y=y_values_max,\n                            fill=None, mode='lines+markers',\n                            line=dict(width=2, dash='dash', color=colors[i * len(config_data[self.lab_group].unique()) + j]),\n                            marker=dict(symbol='x', size=6),\n                            showlegend=False\n                        ))\n                        fig.add_trace(go.Scatter(\n                            x=snr, y=y_values_min,\n                            fill='tonexty', mode='lines+markers',\n                            line=dict(width=2, dash='dash', color=colors[i * len(config_data[self.lab_group].unique()) + j]),\n                            marker=dict(symbol='x', size=6),\n                            name=f"min/max - {alias} - {t}"  \n                        ))\n\n                    \n                    fig.add_trace(go.Scatter(\n                        x=snr, y=y_values,\n                        mode='lines+markers',\n                        line=dict(width=2, color=colors[i * len(config_data[self.lab_group].unique()) + j]),\n                        name=f"{self.lab} - {alias} - {t}"  \n                    ))\n            else :\n                snr = config_data[noiseKey]\n                y_values = config_data[self.lab]         \n                \n                if show_envelope :\n                    y_values_min = config_data[self.labmin]  \n                    y_values_max = config_data[self.labmax]   \n                    \n                    # Courbe pour la latence avec enveloppe\n                    fig.add_trace(go.Scatter(\n                        x=snr, y=y_values_max,\n                        fill=None, mode='lines+markers',\n                        line=dict(width=2, dash='dash', color=colors[i]),\n                        marker=dict(symbol='x', size=6),\n                        showlegend=False\n                    ))\n                    fig.add_trace(go.Scatter(\n                        x=snr, y=y_values_min,\n                        fill='tonexty', mode='lines+markers',\n                        line=dict(width=2, dash='dash', color=colors[i]),\n                        marker=dict(symbol='x', size=6),\n                        name=f"min/max - {config}"  \n                    ))\n\n                \n                fig.add_trace(go.Scatter(\n                    x=snr, y=y_values,\n                    mode='lines+markers',\n                    line=dict(width=2, color=colors[i]),\n                    name=f"{self.lab} - {config}"  \n                ))\n        \n        # Configuration de la mise en page avec Range Slider et Range Selector\n        fig.update_layout(\n            title="Latence en fonction du SNR pour chaque configuration",\n            xaxis=dict(\n                title=f"Niveau de Bruit (SNR) : {noiseKey}",\n                rangeslider=dict(visible=True),\n                rangeselector=dict(\n                    buttons=list([\n                        dict(count=1, label="1dB", step="all", stepmode="backward"),\n                        dict(count=5, label="5dB", step="all", stepmode="backward"),\n                        dict(count=10, label="10dB", step="all", stepmode="backward"),\n                        dict(step="all")\n                    ])\n                )\n            ),\n            yaxis=dict(\n                title=self.Ytitle,\n            ),\n            legend_title="Configurations",\n            template="plotly_white",\n            height=600,\n            showlegend=True,\n            margin=dict(t=70, b=50, l=50, r=10)\n        )\n        \n        return  pn.pane.Plotly(fig, sizing_mode="stretch_width")\n\nclass Tasks_Histogramme(pn.viewable.Viewer):\n    # Param\xe8tres configurables\n    df = param.DataFrame(doc="Le dataframe contenant les donn\xe9es")\n    multi_choice_widget = param.ClassSelector(default=None, class_=pn.viewable.Viewer, doc="Widget MultiChoice")\n    noiseScale = param.ClassSelector(default=None, class_=pn.viewable.Viewer,doc="Choix de l'\xe9chelle de bruit par passage du label de la colonne")\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        \n        self.button_time_perc = pn.widgets.Toggle(name='%', value=True)\n        self.button_time_perc.param.watch(self.changeIcon, 'value')\n        self.ListBouton = pn.Column(\n            pn.widgets.TooltipIcon(value="Affichage des temps des t\xe2ches en milli-seconde ou en %."), \n            self.button_time_perc,\n            width=50)\n        self.graphPanel = pn.bind(self._plot_task_data, self.button_time_perc, self.multi_choice_widget.param.value, self.noiseScale.param.value)\n        \n    def changeIcon(self, event) :\n        if event.new : \n            self.button_time_perc.name = '%'\n        else :\n            self.button_time_perc.name = '\u23f1'\n    \n    def __panel__(self):\n        return pn.Row(self.ListBouton, self.graphPanel)\n    \n    def _plot_task_data(self,percent, index, noiseKey):\n        \n        if index is None :\n            df_filtred = self.df\n        else :\n            df_filtred = self.df.loc[index] \n        \n        if df_filtred.empty:\n            self.button_time_perc.disabled=True\n            return pn.pane.Markdown(f"Graphes de T\xe2ches : Pas de donn\xe9es de t\xe2ches disponibles pour les configurations s\xe9lectionn\xe9es.")\n        else : \n            self.button_time_perc.disabled=False\n            \n        if percent :\n            y_label = ('Time', 'Dur\xe9e')\n        else :\n            y_label = ('Perc','Dur\xe9e (%)')\n        \n        \n        \n        # Pivot des donn\xe9es pour que chaque combinaison Config_Hash + Signal Noise Ratio(SNR).Eb/N0(dB) ait des colonnes pour les temps des t\xe2ches\n        pivot_df = df_filtred.pivot_table(\n            values=y_label[0], \n            index=['Config_Hash', noiseKey], \n            columns='Task',\n            aggfunc='sum', \n            fill_value=0\n        )\n\n        # G\xe9n\xe9rer une palette de couleurs automatiquement selon le nombre de configurations\n        colors = px.colors.qualitative.Plotly[:len(index) * len(df_filtred['Task'].unique())]\n\n        # Initialiser la figure Plotly\n        fig = go.Figure()\n        \n        # Ajouter chaque t\xe2che comme une barre empil\xe9e\n        for task in pivot_df.columns:\n            fig.add_trace(go.Bar(\n                x=pivot_df.index.map(lambda x: f"{config_df.loc[x[0], 'Config_Alias']} - SNR: {x[1]}"),  # Combinaison Config_Hash + SNR comme \xe9tiquette\n                y=pivot_df[task],\n                name=task\n            ))\n\n        # Configuration de la mise en page\n        fig.update_layout(\n            barmode='stack',\n            title=f"Temps des t\xe2ches par Configuration et Niveau de Bruit  : {noiseKey}",\n            xaxis_title="Configuration et Niveau de Bruit",\n            yaxis_title=y_label[1],\n            xaxis=dict(tickangle=25),  # Rotation des \xe9tiquettes de l'axe x\n            template="plotly_white",\n            height=900,\n            showlegend=True,\n            margin=dict(t=70, b=50, l=50, r=10)\n            \n        )\n        return pn.pane.Plotly(fig, sizing_mode="stretch_width")\n\nclass Mutual_information_Panels (pn.viewable.Viewer) :\n    # Param\xe8tres configurables\n    df = param.DataFrame(doc="Le dataframe contenant les donn\xe9es")\n    index_selecter = param.ClassSelector(default=None, class_=pn.viewable.Viewer, doc="Widget MultiChoice")\n    noiseScale = param.ClassSelector(default=None, class_=pn.viewable.Viewer,doc="Choix de l'\xe9chelle de bruit par passage du label de la colonne")\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        \n        self.colors = px.colors.qualitative.Plotly[:len(self.index_selecter.value)]\n        \n        cols = ["Mutual Information.MI", "Mutual Information.MI_min", "Mutual Information.MI_max", "Mutual Information.n_trials"]\n        self.df = self.df [ self.df[cols].notnull().any(axis=1) ]\n        \n        self.plot_mutual_information = Panel_graph_envelope(\n            multi_choice_widget = self.index_selecter,\n            df = self.df,\n            lab   ="Mutual Information.MI", \n            labmin="Mutual Information.MI_min", \n            labmax="Mutual Information.MI_max", \n            Ytitle = "Information mutuelle",\n            noiseScale = self.noiseScale\n        )\n        \n        self.ListBouton = pn.Column(\n            pn.widgets.TooltipIcon(value="Seuls les configuration avec des valeurs pour \\"Mutual Information.MI\\", \\"Mutual Information.MI_min\\", \\"Mutual Information.MI_max\\", \\"Mutual Information.n_trials\\" sont affich\xe9es. "), \n            width=50)\n        self.mutual_information_ntrial = pn.bind(self._plottrial, self.index_selecter.param.value, self.noiseScale.param.value)\n\n    def __panel__(self):\n        return pn.Column(\n            pn.widgets.TooltipIcon(value="Seuls les configuration avec des valeurs pour \\"Mutual Information.MI\\", \\"Mutual Information.MI_min\\", \\"Mutual Information.MI_max\\" sont affich\xe9es. "), \n            pn.Row(self.plot_mutual_information),\n            pn.Row(self.ListBouton, self.mutual_information_ntrial)\n        )\n    \n \n    def _plottrial(self, index, noiseKey): \n        if index is None :\n            df_filtred = self.df\n        else :\n            df_filtred = self.df.loc[index] \n        \n        # Si pas de donn\xe9es de t\xe2ches pour les configurations s\xe9lectionn\xe9es\n        if df_filtred.empty:\n            return pn.pane.Markdown(f"Mutual Information : Pas de donn\xe9es compl\xe8tes d'information mutuelle disponibles pour les configurations s\xe9lectionn\xe9es.")\n\n        # G\xe9n\xe9rer une palette de couleurs automatiquement selon le nombre de configurations\n        fig = go.Figure()\n        \n        # Ajouter une trace pour chaque configuration et t\xe2che\n        for i, config in enumerate(index):\n            # Filtrer les donn\xe9es pour chaque configuration\n            config_data = df_filtred.loc[config]\n            snr = config_data[noiseKey]\n            n_trials = config_data["Mutual Information.n_trials"]         \n                \n            fig.add_trace(go.Scatter(\n                x=snr, y=n_trials,\n                mode='markers',\n                line=dict(width=2, color=colors[i]),\n                name=f"Nombre d'essais - {config}"  \n            ))\n        \n        # Configuration de la mise en page avec Range Slider et Range Selector\n        fig.update_layout(\n            title="Nombre d'essais en fonction du SNR pour chaque configuration",\n            xaxis=dict(\n                title=f"Niveau de Bruit (SNR) : {noiseKey}",\n                rangeslider=dict(visible=True),\n                rangeselector=dict(\n                    buttons=list([\n                        dict(count=1, label="1dB", step="all", stepmode="backward"),\n                        dict(count=5, label="5dB", step="all", stepmode="backward"),\n                        dict(count=10, label="10dB", step="all", stepmode="backward"),\n                        dict(step="all")\n                    ])\n                )\n            ),\n            yaxis=dict(\n                title="Nombre d'essais",\n            ),\n            legend_title="Configurations",\n            template="plotly_white",\n            height=600,\n            showlegend=True,\n            margin=dict(t=70, b=50, l=50, r=10)\n        )\n        \n        return  pn.pane.Plotly(fig, sizing_mode="stretch_width")\n\nclass Research_config_filter(pn.viewable.Viewer):\n    # Param\xe8tres configurables\n    df = param.DataFrame(doc="Le dataframe contenant les donn\xe9es")\n    config_selector = param.ClassSelector(default=None, class_=pn.widgets.MultiChoice, doc="Widget MultiChoice", allow_refs=False)\n    def __init__(self, **params):\n        super().__init__(**params)\n        \n        \n        # Configuration initiale Tout\n        self._config_allowed = {}\n        for col in self.df.columns:\n            self._config_allowed[col] = self.df[col].unique().tolist()\n        \n        # Filtrer les colonnes qui suivent le format "FAMILLE.nom"\n        config_df = self.df\n        # Les colonnes suivantes ne doivent pas avoir de filtre\n        config_df = config_df.drop('Config_Alias', axis=1)\n        \n        family_columns = {}\n        for col in config_df.columns:\n            match = re.match(r"(\\w+)\\.(\\w+)", col)\n            if match:\n                family, name = match.groups()\n                if family not in family_columns:\n                    family_columns[family] = []\n                family_columns[family].append(col)\n            else:\n                # Ajoute les colonnes sans famille dans une cl\xe9 g\xe9n\xe9rale\n                family_columns.setdefault("Autres", []).append(col)\n        \n        # Cr\xe9er les widgets de s\xe9lection pour chaque famille\n        family_widgets = {}\n        for family, columns in family_columns.items():\n            widgets = []\n            for col in columns :\n                options = config_df[col].unique().tolist()\n                is_disabled = len(options) == 1\n                widget = pn.widgets.MultiChoice(name=col, options=options, value=options, disabled=is_disabled, css_classes=["grayed-out"] if is_disabled else [])\n                \n                widget.param.watch(self._update_filterconfig, 'value')\n                widgets.append(widget)\n                \n            family_widgets[family] = pn.Column(*widgets, name=family)\n\n        self.accordion_families = pn.Accordion(*[(f"{family}", widget) for family, widget in family_widgets.items()])\n        \n    def __panel__(self):\n        return pn.Card(self.accordion_families, title="\U0001f50d\\t Filtres de recherche")\n    \n    def _filter_config(self, config_df, config_allowed):\n        # Filtre le DataFrame en fonction des valeurs d\xe9finies dans config_allowed\n        config_filtered_df = config_df.copy()\n        for col, allowed_values in config_allowed.items():\n            if allowed_values:  # S'il y a des valeurs autoris\xe9es pour cette colonne\n                config_filtered_df = config_filtered_df[config_filtered_df[col].isin(allowed_values)]\n        return config_filtered_df.index\n\n    # Callback pour mettre \xe0 jour config_allowed et d\xe9clencher le filtrage\n    def _update_filterconfig(self, event):\n        if len(event.old) > 1 :\n            self._config_allowed[event.obj.name] = event.new\n            #event.obj.param.disabled = len(event.new) == 1 #A tester\n            config_filtered = self._filter_config(config_df, self._config_allowed)\n            self.config_selector.param.config_options= config_filtered\n        else :\n            event.obj.param.value = event.old\n        \nclass TableConfig(pn.viewable.Viewer):\n    df = param.DataFrame(doc="Le dataframe contenant les donn\xe9es")\n    config_selector = param.ClassSelector(default=None, class_=pn.viewable.Viewer, doc="Widget MultiChoice")\n    \n    def __init__(self, **params):\n        super().__init__(**params)\n        filtered_df = self.df.filter(regex=r"^(Meta|Simulation)\\.")\n        filtered_df.columns = filtered_df.columns.str.replace(r"^(Meta\\.|Simulation\\.)", "", regex=True)\n        filtered_df = filtered_df.loc[self.config_selector.value]\n        self.tab =  pn.pane.DataFrame(filtered_df, name='table.selected_config', text_align = 'center', index=False)\n\n    def __panel__(self):\n        return pn.Accordion( ("\U0001f4e5 Selected Configuration", self.tab))\n    \n    @param.depends('config_selector.value', watch=True)\n    def table_selected_config_filter(self):\n        filtered_df  = self.df.loc[config_selector.value].filter(regex=r"^(Meta|Simulation)\\.")\n        filtered_df.columns = filtered_df.columns.str.replace(r"^(Meta\\.|Simulation\\.)", "", regex=True)\n        self.tab.object = filtered_df\n\n\n##################################### Chargement ####################################\n\n# Charger les donn\xe9es si elles existent\ndef load_data():\n    def csvread(name):\n        path = args.database_path + name + '.csv'\n        \n        if os.path.exists(path) :\n            # Chargement depuis le chemin local\n            ret = pd.read_csv(path)\n        else:\n            # Gestion de l'environnement Pyodide\n            if "pyodide" in sys.modules:\n                # Utiliser le lien "raw" de GitHub pour un acc\xe8s direct\n                url = f"https://raw.githubusercontent.com/fCheminadeInria/aff3ct.github.io/master/comit_dashboard/database/{name}.csv"\n                try:\n                    with open_url(url) as file:\n                        ret = pd.read_csv(file)\n                except Exception as e:\n                    print(f"Echec au chargement de {name} depuis {url} : {e}")\n                    ret = pd.DataFrame()  # Retourne un DataFrame vide en cas d'\xe9chec\n            else:\n                print(f"Echec au chargement de {name} : {path} (fichier introuvable)")\n                ret = pd.DataFrame()  # Retourne un DataFrame vide si le fichier n'existe pas\n        \n        return ret\n    \n    config_df      = csvread('config')\n    config_df.set_index('Config_Hash', inplace=True)\n    \n    task_df        = csvread('tasks')\n    task_df.set_index('Config_Hash', inplace=True)\n    \n    performance_df = csvread('performances')\n    performance_df.set_index('Config_Hash', inplace=True)\n    \n    git_df         = csvread('log_git')\n    \n    git_df.set_index('echo sha', inplace=True)\n    git_df['date'] = pd.to_datetime(git_df['date'],utc=True) \n    \n    # Cr\xe9er un dictionnaire de correspondance Config_Hash \u2192 Config_Alias\n    config_df['Config_Alias'] = config_df['Meta.GitVersion'] + "_"  +  config_df['Meta.Command_short'] + "(" + config_df.index.str[:8] + ")"\n    config_aliases = dict(zip(config_df.index, config_df['Config_Alias']))\n    \n    return config_df, task_df, performance_df, git_df, config_aliases\n\n# Configurer argparse pour g\xe9rer les arguments en ligne de commande\ndef parse_arguments():\n    parser = argparse.ArgumentParser(description="Tableau de bord des commits.")\n    parser.add_argument('-l', '--local', action="store_true", help="Local affiche le tableau de bord dans le navigateur, son absence permet son export.")  # on/off flag\n    parser.add_argument('--database_path', default='./comit_dashboard/database/', help="Remplace le chemin par d\xe9faut (./comit_dashboard/database/) vers la base de donn\xe9es.")  # on/off flag\n    return parser.parse_args()\n\n # Utiliser des valeurs par d\xe9faut dans le cas d'un export qui ne supporte pas argparse\nclass DefaultArgs:\n    local = False\n    database_path = "./comit_dashboard/database/"\nargs = DefaultArgs()\nif __name__ == "__main__":\n    args = parse_arguments()  # Appel unique de argparse ici\n\n# Charger les donn\xe9es initiales\nconfig_df, task_df, performance_df, git_df, config_aliases = load_data()\n\n##################################### Panel Donn\xe9es ####################################\n\n# Widgets d'affichage des informations\nconfig_count = pn.indicators.Number(name="Nombre de configurations", value=config_df.index.nunique() if not config_df.empty else 0)\ngit_version_count = pn.indicators.Number(name="Nombre de versions Git avec des donn\xe9es", value=config_df['Meta.GitVersion'].nunique() if not config_df.empty else 0)\ncommit_count = pn.indicators.Number(name="Nombre de commits historis\xe9s dans Git", value=git_df .index.nunique() if not git_df.empty else 0)\n\n# Cr\xe9er un indicateur pour afficher la date du commit le plus r\xe9cent\nlatest_commit_date = git_df['date'].max() if not git_df.empty else "Aucune date disponible"\nlatest_commit_date_str = latest_commit_date.strftime('%Y-%m-%d %H:%M:%S') if latest_commit_date != "Aucune date disponible" else latest_commit_date\n\n# Extraire la date du commit le plus r\xe9cent\nlatest_commit_date = git_df['date'].max() if not git_df.empty else "Aucune date disponible"\n\n# Cr\xe9er un widget statique pour afficher la date du commit le plus r\xe9cent\nlatest_commit_date_display = pn.Column(\n        pn.widgets.StaticText(name="Date du dernier commit",css_classes=["tittle_indicator-text"]),\n        pn.widgets.StaticText(value=str(latest_commit_date),css_classes=["indicator-text"])\n)\n\npn.config.raw_css = [\n    """\n    .tittle_indicator-text {\n        font-size: 20px;\n        font-weight: normal;\n        color: #333333;\n    }\n    .indicator-text {\n        font-size: 64px;\n        font-weight: normal;\n        color: #333333;\n    }\n    """\n]\n\n#panel de la partie data\npanelData = pn.Column(config_count, \n                   git_version_count, \n                   commit_count,\n                   latest_commit_date_display,\n        sizing_mode="stretch_width")\n\n##################################### Param\xeatre du site ####################################\n\nnoise_label ={}\nnoise_label['Eb/N0'] = 'Signal Noise Ratio(SNR).Eb/N0(dB)'\nnoise_label['Es/N0'] = 'Signal Noise Ratio(SNR).Es/N0(dB)'\nnoise_label['Sigma'] = 'Signal Noise Ratio(SNR).Sigma'\n\nnoiseScale = NoiseScale(noise_label= noise_label)\n\nparamSite = noiseScale\n\npn.config.raw_css.append("""\n.align-right {\n    margin-left: auto;\n    display: flex;\n    justify-content: flex-end;\n}\n""")\n\n##################################### Panel Git ####################################\n\ndef filter_data(git_df, project, date_range):\n    start_date, end_date = date_range\n    # Filtrage par date \n    start_date = datetime.combine(date_range[0], datetime.min.time())\n    end_date   = datetime.combine(date_range[1], datetime.min.time())\n    \n    # Convertir les dates de la colonne 'date' de git_df en tz-naive\n    git_df['date'] = git_df['date'].dt.tz_localize(None)\n\n    # Filtrage des donn\xe9es en fonction de la plage de dates\n    filtered_df = git_df[(git_df['date'] >= start_date) & (git_df['date'] <= end_date)]   \n    \n    # Filtrage par projet, si ce n'est pas 'Tous'\n    if project != 'Tous':\n        filtered_df = filtered_df[filtered_df['Project'] == project]\n    \n    # Mise \xe0 jour de la table avec les donn\xe9es filtr\xe9es\n    table_commit.value = filtered_df\n\n# Lier le filtre au slider et au RadioButton\ndef update_filter(event):\n    project = project_radio_button.value\n    date_range = date_range_slider.value\n    filter_data(git_df, project, date_range)\n\n# Radiobouton\n# Extraire les projets uniques de git_df et ajouter "Tous"\nprojects = git_df['Project'].unique().tolist()\nprojects.append('Tous')  # Ajout de l'option 'Tous'\n\n# Cr\xe9er le widget RadioButton\nproject_radio_button = pn.widgets.RadioButtonGroup(\n    name='S\xe9lectionner un projet',\n    options=projects,\n    value='Tous'  # Option par d\xe9faut\n)\n\n# Configuration de l'intervalle de dates pour le DateRangeSlider\nmin_date = git_df['date'].min() if not git_df.empty else datetime(2000, 1, 1)\nmax_date = git_df['date'].max() if not git_df.empty else datetime.now()\n\n# Cr\xe9ation du DateRangeSlider\ndate_range_slider = pn.widgets.DateRangeSlider(\n    name="S\xe9lectionnez l'intervalle de dates",\n    start=min_date,\n    end=max_date,\n    value=(min_date, max_date),\n)\n\n#table de donn\xe9es Git\ntable_commit = pn.widgets.DataFrame(git_df, name='Table de Donn\xe9es', text_align = 'center')\n\n# Lier les \xe9v\xe9nements aux widgets\nproject_radio_button.param.watch(update_filter, 'value')\ndate_range_slider.param.watch(update_filter, 'value')\n\n# Initialisation de la table avec les donn\xe9es filtr\xe9es par d\xe9faut\nfilter_data(git_df, project_radio_button.value, date_range_slider.value)\n\npanelCommit = pn.Column(\n    pn.Column(project_radio_button, date_range_slider),\n    table_commit,\n)\n\n##################################### Config ####################################\n\n# Performance par niveau de bruit pour les configurations s\xe9lectionn\xe9es\ndef plot_performance_metrics_plotly(configs, noiseScale):\n    # Si aucune configuration n'est s\xe9lectionn\xe9e\n    if not configs:\n        return pn.pane.Markdown("Veuillez s\xe9lectionner au moins une configuration pour afficher les performances.")\n    \n    filtered_performance_df = performance_df.loc[configs]\n    if filtered_performance_df.empty:\n        return pn.pane.Markdown("Pas de donn\xe9es de performance disponibles pour les configurations s\xe9lectionn\xe9es.")\n    \n    fig = go.Figure()\n    \n    # G\xe9n\xe9rer une palette de couleurs automatiquement selon le nombre de configurations\n    colors = px.colors.qualitative.Plotly[:len(configs)]  # Choisir des couleurs depuis Plotly, ajust\xe9es \xe0 la taille de configs\n    \n    for i, config in enumerate(configs):\n        config_data = filtered_performance_df.loc[config]\n        snr = config_data[noiseScale]\n        ber = config_data['Bit Error Rate (BER) and Frame Error Rate (FER).BER']\n        fer = config_data['Bit Error Rate (BER) and Frame Error Rate (FER).FER']\n        \n        # Trace BER (ligne pleine avec marqueurs)\n        fig.add_trace(go.Scatter(\n            x=snr, y=ber, mode='lines+markers', name=f"BER - {config}",\n            line=dict(width=2, color=colors[i]),\n            marker=dict(symbol='circle', size=6)\n        ))\n        \n        # Trace FER (ligne pointill\xe9e avec marqueurs)\n        fig.add_trace(go.Scatter(\n            x=snr, y=fer, mode='lines+markers', name=f"FER - {config}",\n            line=dict(width=2, dash='dash', color=colors[i]),\n            marker=dict(symbol='x', size=6)\n        ))\n    \n    \n    # Configuration de la mise en page avec Range Slider et Range Selector\n    fig.update_layout(\n        title="BER et FER en fonction du SNR pour chaque configuration",\n        xaxis=dict(\n            title=f"Niveau de Bruit (SNR) : {noiseScale}",\n            rangeslider=dict(visible=True),  # Activation du Range Slider\n            rangeselector=dict(\n                buttons=list([\n                    dict(count=1, label="1dB", step="all", stepmode="backward"),\n                    dict(count=5, label="5dB", step="all", stepmode="backward"),\n                    dict(count=10, label="10dB", step="all", stepmode="backward"),\n                    dict(step="all")\n                ])\n            )\n        ),\n        yaxis=dict(\n            title="Taux d'Erreur",\n            type='log'\n        ),\n        legend_title="Configurations",\n        template="plotly_white",\n        height=600,\n        showlegend=True,\n        margin=dict(t=70, b=50, l=50, r=10)\n    )\n    \n    return pn.pane.Plotly(fig, sizing_mode="stretch_width")\n\n\n#research_config_filter = Research_config_filter(config_selector = config_selector, df = config_df)\nconfig_selector = ConfigPanel(df = config_df)\n\nmi_panel = pn.Column(\n    Mutual_information_Panels(\n        df = performance_df,\n        index_selecter = config_selector,\n        noiseScale =noiseScale\n    ),\n    scroll=True, height=700\n)\n\n\n# panel des configs\npanelConfig = pn.Row(\n    #pn.Column(select_all_button, clear_button, config_selector, research_config_filter, width=300),\n    config_selector,\n    pn.Column(\n        TableConfig(df=config_df, config_selector=config_selector),\n        pn.Tabs(\n            ('\u0131l\u0131\u0131l\u0131\u0131l\u0131\u0131l\u0131\u0131l\u0131\u0131l\u0131 BER/FER', pn.bind(plot_performance_metrics_plotly, config_selector.param.value, noiseScale.param.value)),\n            ('\u2ad8\u2ad8\u2ad8 Mutual information', mi_panel)\n        ),\n        sizing_mode="stretch_width"\n    )\n)\n\n##################################### Performance par niveau de SNR ####################################\n\n# Histogramme des temps des jobs\ntask_Time_Histogramme = Tasks_Histogramme(\n    multi_choice_widget = config_selector,\n    df = task_df,\n    noiseScale = noiseScale\n) \n\nplot_debit = Panel_graph_envelope(\n    multi_choice_widget = config_selector,\n    df = task_df,\n    lab ="Measured throughput Average", \n    labmin="Measured throughput Mininmum", \n    labmax="Measured throughputMaximum", \n    lab_group='Task',\n    Ytitle = "D\xe9bit",\n    noiseScale = noiseScale\n)\n\nplot_latence = Panel_graph_envelope(\n    multi_choice_widget = config_selector,\n    df = task_df,\n    lab ="Measured latency Average", \n    labmin="Measured latency Mininmum", \n    labmax="Measured latency Maximum", \n    lab_group='Task',\n    Ytitle = "Latence",\n    noiseScale = noiseScale\n)    \n    \npanel_level_noise = pn.Column(\n    task_Time_Histogramme,\n    plot_latence,\n    plot_debit,\n    sizing_mode="stretch_width"\n)\n\n##################################### Tableau de bord ####################################\n\n# Panneaux des performances\npanel_Performances = pn.Column(\n    \n    sizing_mode="stretch_width"\n)\n\n# Layout du tableau de bord avec tout dans une colonne et des arri\xe8res-plans diff\xe9rents\ndashboard = pn.Column(\n    pn.pane.HTML("<div style='font-size: 28px;background-color: #e0e0e0; padding: 10px;line-height : 0px;'><h2> \u270f\ufe0f Git</h2></div>"),\n    panelCommit,\n    pn.pane.HTML("<div style='font-size: 28px;background-color: #e0e0e0; padding: 10px;line-height : 0px;'><h2> \u260e\ufe0f Performances m\xe9tiers </h2></div>"),\n    panelConfig,\n    pn.pane.HTML("<div style='font-size: 28px;background-color: #e0e0e0; padding: 10px;line-height : 0px;'><h2> \u2699\ufe0f IT performances</h2></div>"),\n    panel_level_noise,\n    )\n\nACCENT = "teal"\n\nstyles = {\n    "box-shadow": "rgba(50, 50, 93, 0.25) 0px 6px 12px -2px, rgba(0, 0, 0, 0.3) 0px 3px 7px -3px",\n    "border-radius": "4px",\n    "padding": "10px",\n  }\n\ndashboard= pn.template.FastListTemplate(\n    title="Commits Dashboard",\n    sidebar=[pn.pane.Image("https://github.com/fCheminadeInria/aff3ct.github.io/blob/master/comit_dashboard/image/431ba575-dd6f-422e-b843-7e6c826a3b78.webp"), panelData, pn.layout.Divider(), paramSite],\n    main=[dashboard],\n    main_layout=None,\n    accent=ACCENT,\n    theme_toggle=False,\n)\n\n\n# Lancer le tableau de bord\nif args.local :\n    dashboard.show()\nelse :\n    dashboard.servable()\n\n\n\n\n\n\n\n\n\n\n\nawait write_doc()
  `

  try {
    const [docs_json, render_items, root_ids] = await self.pyodide.runPythonAsync(code)
    self.postMessage({
      type: 'render',
      docs_json: docs_json,
      render_items: render_items,
      root_ids: root_ids
    })
  } catch(e) {
    const traceback = `${e}`
    const tblines = traceback.split('\n')
    self.postMessage({
      type: 'status',
      msg: tblines[tblines.length-2]
    });
    throw e
  }
}

self.onmessage = async (event) => {
  const msg = event.data
  if (msg.type === 'rendered') {
    self.pyodide.runPythonAsync(`
    from panel.io.state import state
    from panel.io.pyodide import _link_docs_worker

    _link_docs_worker(state.curdoc, sendPatch, setter='js')
    `)
  } else if (msg.type === 'patch') {
    self.pyodide.globals.set('patch', msg.patch)
    self.pyodide.runPythonAsync(`
    from panel.io.pyodide import _convert_json_patch
    state.curdoc.apply_json_patch(_convert_json_patch(patch), setter='js')
    `)
    self.postMessage({type: 'idle'})
  } else if (msg.type === 'location') {
    self.pyodide.globals.set('location', msg.location)
    self.pyodide.runPythonAsync(`
    import json
    from panel.io.state import state
    from panel.util import edit_readonly
    if state.location:
        loc_data = json.loads(location)
        with edit_readonly(state.location):
            state.location.param.update({
                k: v for k, v in loc_data.items() if k in state.location.param
            })
    `)
  }
}

startApplication()