importScripts("https://cdn.jsdelivr.net/pyodide/v0.27.0/full/pyodide.js");

function sendPatch(patch, buffers, msg_id) {
  self.postMessage({
    type: 'patch',
    patch: patch,
    buffers: buffers
  })
}

async function startApplication() {
  console.log("Loading pyodide!");
  self.postMessage({type: 'status', msg: 'Loading pyodide'})
  self.pyodide = await loadPyodide();
  self.pyodide.globals.set("sendPatch", sendPatch);
  console.log("Loaded!");
  await self.pyodide.loadPackage("micropip");
  const env_spec = ['https://cdn.holoviz.org/panel/wheels/bokeh-3.6.0-py3-none-any.whl', 'https://cdn.holoviz.org/panel/1.6.0/dist/wheels/panel-1.6.0-py3-none-any.whl', 'pyodide-http==0.2.1', 'pandas', 'param', 'plotly', 'pyarrow']
  for (const pkg of env_spec) {
    let pkg_name;
    if (pkg.endsWith('.whl')) {
      pkg_name = pkg.split('/').slice(-1)[0].split('-')[0]
    } else {
      pkg_name = pkg
    }
    self.postMessage({type: 'status', msg: `Installing ${pkg_name}`})
    try {
      await self.pyodide.runPythonAsync(`
        import micropip
        await micropip.install('${pkg}');
      `);
    } catch(e) {
      console.log(e)
      self.postMessage({
	type: 'status',
	msg: `Error while installing ${pkg_name}`
      });
    }
  }
  console.log("Packages loaded!");
  self.postMessage({type: 'status', msg: 'Executing code'})
  const code = `
  \nimport asyncio\n\nfrom panel.io.pyodide import init_doc, write_doc\n\ninit_doc()\n\nfrom bokeh.settings import settings\nsettings.resources = 'inline'\n\nimport pandas as pd\nimport panel as pn\nimport plotly.graph_objs as go\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport param\nimport unicodedata as ud\nfrom io import BytesIO\nimport sys\nimport os\nimport unicodedata as ud\nimport urllib.request\n\ntry:\n    import pyarrow.parquet as pq\nexcept ImportError:\n    pq = None\n\n# ------------------------------------------------------------------------------\n#  Variables d\u2019environnement\n# ------------------------------------------------------------------------------\nIS_PYODIDE       = sys.platform == "emscripten"\nIS_PANEL_CONVERT = os.getenv("PANEL_CONVERT") == "1"\nGITLAB_PACKAGE_URL = "https://gitlab.inria.fr/api/v4/projects/1420/packages/generic/gitlab-elk-export/latest/export/"\nBUTON_WIDTH = 60\n# ------------------------------------------------------------------------------\n#  Chargement des donn\xe9es \u2013 SYNCHRONE\n# ------------------------------------------------------------------------------\n\ndef load_table(name: str, fmt: str = "parquet") -> pd.DataFrame:\n    \n    url = f"{GITLAB_PACKAGE_URL}{name}.{fmt}"\n    CHUNK = 1024 * 1024          # 1 Mo par appel\n\n    headers = {\n        "User-Agent": "Mozilla/5.0",\n    }\n\n    all_data = BytesIO()\n    start = 0\n\n    while True:\n        headers["Range"] = f"bytes={start}-{start + CHUNK - 1}"\n        req = urllib.request.Request(url, headers=headers)\n        try:\n            with urllib.request.urlopen(req, timeout=None) as resp:\n                data = resp.read()\n                if not data:          # plus rien\n                    break\n                all_data.write(data)\n                if len(data) < CHUNK: # dernier morceau\n                    break\n                start += len(data)\n        except urllib.error.HTTPError as e:\n            if e.code == 416:         # Range Not Satisfiable \u2192 fin atteinte\n                break\n            else:\n                raise\n\n    all_data.seek(0)\n    if fmt == "json":\n        df = pd.read_json(all_data, lines=True)\n        if len(df) == 1 and df.isna().all(axis=None):\n            # Retrait de la ligne factice\n            empty_df = df.iloc[:0].reset_index(drop=True)\n            empty_df = empty_df.astype("string")  # Force un type neutre\n            return empty_df\n        return df\n    elif fmt == "parquet":\n        return pd.read_parquet(all_data)\n    else:\n        return pd.DataFrame()\n\ndef load_data_sync() -> None:\n    """Charge toutes les tables dans pn.state.cache['db'] (synchrone)."""\n    print("\u2699\ufe0f load_data_sync() appel\xe9")\n    fmt='json'\n    \n    tables = [\n        'git',\n        'command',\n        'parameters',\n        'exec',\n        'runs',\n    ]\n    db = dict()\n    for table in tables:\n        db[table] = load_table(table, fmt)\n        print(f"{tables.index(table) + 1}/{len(tables)} {table} charg\xe9 : {len(db[table])} lignes")\n\n    if db['command'].empty:\n        raise ValueError("Impossible de charger les donn\xe9es pour 'command'. Veuillez v\xe9rifier l'URL et les d\xe9pendances.")\n    db['command'].set_index('Command_id', inplace=True)\n\n    db['parameters'].set_index('param_id', inplace=True)\n    \n    db['runs'].set_index('RUN_id', inplace=True)\n    \n    db['git'].set_index('sha1', inplace=True)\n\n    # Alias\n    db['command']['Config_Alias'] = (\n        db['command'].index.astype(str) + " : " +\n        db['command']['Command_short'].astype(str)\n    )\n    \n    db['exec'].set_index('log_hash', inplace=True)\n    db['exec']['Date_Execution'] = pd.to_datetime(db['exec']['Date_Execution'], unit='ms', errors='coerce')\n    db['exec']["alias"] = db['exec']['EXEC_id'] + " : " + db['exec']['Date_Execution'].dt.strftime('%Y-%m-%d %H:%M:%S, (Sha1 : ') +  db['exec']['sha1']  + ")"\n\n    pn.state.cache['db'] = db\n\n    apply_typing_code()\n        \n    print("\u2705 load_data_sync() termin\xe9")\n    \n# ------------------------------------------------------------------------------\n#  Typage automatique (copi\xe9-coll\xe9 de la version JSON)\n# ------------------------------------------------------------------------------\n\ndef apply_typing_code():\n    ''' Applique le typage des donn\xe9es  (copier coller du r\xe9sultat de generate_typing_code) ''' \n    # Typage pour runs\n    runs = pn.state.cache['db']['runs']\n    \n    to_convert = {\n        'Bit Error Rate (BER) and Frame Error Rate (FER).BE': 'Int64',\n        'Bit Error Rate (BER) and Frame Error Rate (FER).BER': 'float',\n        'Bit Error Rate (BER) and Frame Error Rate (FER).FE': 'Int64',\n        'Bit Error Rate (BER) and Frame Error Rate (FER).FER': 'float',\n        'Bit Error Rate (BER) and Frame Error Rate (FER).FRA': 'Int64',\n        'Global throughput and elapsed time.SIM_THR(Mb/s)': 'float',\n        'Global throughput and elapsed time.elapse_time(ms)': 'float',\n        'Signal Noise Ratio(SNR).Eb/N0(dB)': 'float',\n        'Signal Noise Ratio(SNR).Es/N0(dB)': 'float',\n        'Signal Noise Ratio(SNR).Sigma': 'float',\n        'Signal Noise Ratio(SNR).Event Probability': 'float',\n        'Signal Noise Ratio(SNR).Received Optical': 'float',\n    }\n    \n    for col, dtype in to_convert.items():\n        runs[col] = pd.to_numeric(runs[col], errors='coerce')\n        if dtype == 'Int64':\n            runs[col] = runs[col].astype('Int64')\n            \n            \n    pn.state.cache['db']['runs'] = runs\n\n    # Typage pour git\n    git = pn.state.cache['db']['git']\n    git['author'] = git['author'].astype(str)\n    git['email'] = git['email'].astype(str)\n    git['date'] = pd.to_datetime(git['date'], errors='coerce')\n    git['message'] = git['message'].astype(str)\n    git['insertions'] = pd.to_numeric(git['insertions'], errors='coerce').astype('Int64')\n    git['deletions'] = pd.to_numeric(git['deletions'], errors='coerce').astype('Int64')\n    git['files_changed'] = pd.to_numeric(git['files_changed'], errors='coerce').astype('Int64')\n    pn.state.cache['db']['git'] = git\n\n# ------------------------------------------------------------------------------\n#  Initialisation du dashboard\n# ------------------------------------------------------------------------------\ndef init_dashboard():\n    print("\u2699\ufe0f init_dashboard() appel\xe9")\n\n    db = pn.state.cache['db']\n\n    git_model = GitFilterModel(df_git=db['git'])\n\n    command_model = CommandFilterModel(git_filter=git_model)\n    panelCommit = PanelCommit(command_filter=command_model, git_filter=git_model)\n\n    lvl2_model = Lvl2_Filter_Model(command_filter=command_model)\n    config_panel = Lvl2_ConfigPanel(lv2_model=lvl2_model)\n\n    panelConfig = pn.Row(\n        pn.Column(\n            TableConfig(lvl2_model=lvl2_model),\n            config_panel,\n            Lvl2_Git_Selector(lv2_model=lvl2_model),\n            pn.Tabs(\n                ('BER/FER', PerformanceBERFERPlot(lvl2_model = lvl2_model, noise_scale_param=noiseScale))),\n            sizing_mode="stretch_width"\n        )\n    )\n\n    lvl3 = Level3(lvl2_model=lvl2_model)\n\n    panelData = pn.Column(\n        pn.indicators.Number(\n        name="Commits en base",\n        value=db['git'].shape[0] if not db['git'].empty else 0\n        ),\n        pn.indicators.Number(\n        name="Commandes en base",\n        value=db['command'].shape[0] if not db['command'].empty else 0\n        ), \n        pn.indicators.Number(\n            name="Executions en base",\n            value=db['exec'].shape[0] if not db['exec'].empty else 0\n        ),\n        RunsCountIndicator(git_filter=git_model), \n        sizing_mode="stretch_width")\n\n    dashboard = pn.Column(\n        pn.pane.HTML("<h2>\u270f\ufe0f Niveau 1 : Evolution par commit</h2>"),\n        panelCommit,\n        pn.pane.HTML("<h2>\u260e\ufe0f Niveau 2 : BER / FER</h2>"),\n        panelConfig,\n        pn.pane.HTML("<h2>\u2699\ufe0f Niveau 3 : Analyse par ex\xe9cutions</h2>"),\n        lvl3,\n        sizing_mode="stretch_width"\n    )\n\n    logo = pn.pane.Image(\n        "https://raw.githubusercontent.com/fCheminadeInria/aff3ct.github.io/"\n        "refs/heads/master/comit_dashboard/image/93988066-1f77-4b42-941f-1d5ef89ddca2.webp",\n        width=200\n    )\n\n    template = pn.template.FastListTemplate(\n        title="Tableau de bord de suivi des commits",\n        sidebar=[logo, noiseScale, pn.layout.Divider(), panelData],\n        main=[dashboard],\n        main_layout=None,\n        accent="teal",\n        theme_toggle=False,\n    )\n\n    print("\u2705 init_dashboard() termin\xe9")\n    return template\n\n# ------------------------------------------------------------------------------\n#  Fonctions utilitaires\n# ------------------------------------------------------------------------------\n\ndef command_alias_to_command_id(alias: str) -> str:\n    """\n    Convertit un alias de configuration en Command_id.\n    \n    Args:\n        alias (str): L'alias de la configuration.\n        \n    Returns:\n        str: Le Command_id correspondant ou None si non trouv\xe9.\n    """\n    db = pn.state.cache.get('db', {})\n    df = db.get('command', pd.DataFrame())\n    \n    if df.empty or 'Config_Alias' not in df.columns:\n        return None\n    \n    match = df[df['Config_Alias'] == alias]\n    if not match.empty:\n        return match.index[0]  # Renvoie le Command_id\n    else:\n        return None\n\ndef command_id_to_alias(command_id: str) -> str:\n    """\n    Convertit un Command_id en alias de configuration.\n    \n    Args:\n        command_id (str): Le Command_id de la configuration.\n        \n    Returns:\n        str: L'alias de la configuration ou None si non trouv\xe9.\n    """\n    db = pn.state.cache.get('db', {})\n    df = db.get('command', pd.DataFrame())\n    \n    if df.empty or 'Config_Alias' not in df.columns:\n        return None\n    \n    if command_id in df.index:\n        return df.loc[command_id, 'Config_Alias']\n    else:\n        return None\n\ndef exec_alias_to_log_hash(alias: str) -> str:\n    """\n    Convertit un alias d'ex\xe9cution en log_hash.\n    \n    Args:\n        alias (str): L'alias de l'ex\xe9cution.\n        \n    Returns:\n        str: Le log_hash correspondant ou None si non trouv\xe9.\n    """\n    db = pn.state.cache.get('db', {})\n    df_exec = db.get('exec', pd.DataFrame())\n    \n    if df_exec.empty or 'alias' not in df_exec.columns:\n        return None\n    \n    match = df_exec[df_exec['alias'] == alias]\n    if not match.empty:\n        return match.index[0]  # Renvoie le log_hash\n    else:\n        return None\n    \ndef exec_log_hash_to_alias(log_hash: str) -> str:\n    """\n    Convertit un log_hash en alias d'ex\xe9cution.\n    \n    Args:\n        log_hash (str): Le log_hash de l'ex\xe9cution.\n        \n    Returns:\n        str: L'alias de l'ex\xe9cution ou None si non trouv\xe9.\n    """\n    db = pn.state.cache.get('db', {})\n    df_exec = db.get('exec', pd.DataFrame())\n    \n    if df_exec.empty or 'alias' not in df_exec.columns:\n        return None\n    \n    if log_hash in df_exec.index:\n        return df_exec.loc[log_hash, 'alias']\n    else:\n        return None    \n\n##################################### Niveau Global ####################################\n\nIS_PYODIDE       = sys.platform == "emscripten"\nIS_PANEL_CONVERT = os.getenv("PANEL_CONVERT") == "1"\n\n# Initialiser Panel\npn.extension(\n    "plotly", \n    sizing_mode="stretch_width", \n    )\n\n##################################### Variable statiques ####################################\nnoise_label = {\n    'Eb/N0': 'Signal Noise Ratio(SNR).Eb/N0(dB)',\n    'Es/N0': 'Signal Noise Ratio(SNR).Es/N0(dB)',\n    'Sigma': 'Signal Noise Ratio(SNR).Sigma',\n}\n\n######################\n## Echelle de bruit ##\n######################\n\nclass NoiseScale (pn.viewable.Viewer) :\n    value = param.String(default= 'Signal Noise Ratio(SNR).Eb/N0(dB)', allow_refs=True)\n    noise_label = param.Dict()\n    \n    def __init__ (self, **params):\n        super().__init__(**params)\n        \n        self.radio_group = pn.widgets.RadioBoxGroup(\n            name='Echelle de bruit', \n            options=list(self.noise_label.keys()), \n            value=list(self.noise_label.keys())[0], \n            inline=True )\n        self._update_value(None)\n        self.radio_group.param.watch(self._update_value, "value")\n\n    def __panel__(self):\n        return pn.Column(\n            pn.pane.Markdown(f"**{self.radio_group.name} :** "),\n            pn.Row(self.radio_group, css_classes=["align-right"],sizing_mode="stretch_width"),\n            sizing_mode="stretch_width")\n\n    def _update_value(self, event):\n        """\n        Met \xe0 jour la propri\xe9t\xe9 \`value\` en fonction de la s\xe9lection.\n        """\n        self.value = self.noise_label[self.radio_group.value]\n\n##################################### Mod\xe8le de donn\xe9es ####################################\n\n##################################\n## Gestion des donn\xe9es niveau 1 ##\n##################################\n\nclass GitFilterModel(param.Parameterized):\n    """Mod\xe8le pour filtrer les donn\xe9es Git par plage de dates."""\n    df_git = param.DataFrame()\n    date_range = param.Tuple(default=(None, None), length=2, doc="Plage de dates pour filtrer")\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        # Si date_range n'est pas fourni, on initialise avec la plage compl\xe8te des dates\n        db = pn.state.cache['db']\n        if db['runs'].empty:\n            loaded_runs=[]\n        else:\n            loaded_runs = db['runs']['log_hash'].tolist()\n        loaded_sha1 = db['exec'][db['exec'].index.isin(loaded_runs)]['sha1'].tolist()\n        \n        git_exec = db['git'][db['git'].index.isin(loaded_sha1)]\n        \n        if self.date_range == (None, None):\n            min_date = git_exec['date'].min() if not git_exec.empty else db ['git']['date'].max()\n            max_date = db ['git']['date'].max()\n            self.date_range = (min_date, max_date)\n\n    @param.depends('date_range', watch=True)\n    def set_filtered_df(self):\n        db = pn.state.cache['db']\n        df = db ['git'].copy()\n        start, end = self.date_range\n        if start and end:\n            start = pd.to_datetime(start).floor('s')\n            end   = pd.to_datetime(end).ceil('s')\n            df = df[(df['date'] >= start) & (df['date'] <= end)]\n        self.df_git = df\n    \n    def get_sha1_valids(self):\n        return self.df_git.index.unique()\n\n    @param.depends('df_git', watch=True)\n    def load_runs_from_commit(self):\n        """Charge les runs associ\xe9es \xe0 une liste de commits s'ils ne sont pas d\xe9j\xe0 en m\xe9moire."""\n\n        db = pn.state.cache['db']\n\n        # 1. SHA1 d\xe9j\xe0 charg\xe9s (on regarde les runs d\xe9j\xe0 pr\xe9sents et on r\xe9cup\xe8re les sha1 correspondants)\n        if db['runs'].empty:\n            loaded_runs =[]\n        else:    \n            loaded_runs = db['runs']['log_hash'].tolist()\n        loaded_sha1 = db['exec'][db['exec'].index.isin(loaded_runs)]['sha1'].tolist()\n\n        # 2. SHA1 \xe0 charger = diff\xe9rence parmi ceux qui ont une execution\n        sha1_to_load = self.get_sha1_valids().difference(loaded_sha1)\n        sha1_to_load = sha1_to_load.intersection(db['exec']['sha1'])\n\n        for sha1 in sha1_to_load:\n            df_runs_part = load_table(f"runs/runs_{sha1}", fmt='json')\n            if df_runs_part.empty:\n                continue  # on passe au suivant\n\n            df_runs_part.set_index('RUN_id', inplace=True)\n\n            # 3. Conversion des colonnes num\xe9riques\n            to_convert = {\n                'Bit Error Rate (BER) and Frame Error Rate (FER).BE': 'Int64',\n                'Bit Error Rate (BER) and Frame Error Rate (FER).BER': 'float',\n                'Bit Error Rate (BER) and Frame Error Rate (FER).FE': 'Int64',\n                'Bit Error Rate (BER) and Frame Error Rate (FER).FER': 'float',\n                'Bit Error Rate (BER) and Frame Error Rate (FER).FRA': 'Int64',\n                'Global throughput and elapsed time.SIM_THR(Mb/s)': 'float',\n                'Global throughput and elapsed time.elapse_time(ms)': 'float',\n                'Signal Noise Ratio(SNR).Eb/N0(dB)': 'float',\n                'Signal Noise Ratio(SNR).Es/N0(dB)': 'float',\n                'Signal Noise Ratio(SNR).Sigma': 'float',\n                'Signal Noise Ratio(SNR).Event Probability': 'float',\n                'Signal Noise Ratio(SNR).Received Optical': 'float',\n            }\n\n            for col, dtype in to_convert.items():\n                df_runs_part[col] = pd.to_numeric(df_runs_part[col], errors='coerce')\n                if dtype == 'Int64':\n                    df_runs_part[col] = df_runs_part[col].astype('Int64')\n\n            # 5. Ajout au DataFrame principal\n            db['runs'] = pd.concat([db['runs'], df_runs_part])\n\n        # 6. Mise \xe0 jour du cache\n        pn.state.cache['db'] = db\n\nclass CommandFilterModel(param.Parameterized):\n    """Mod\xe8le pour filtrer les commandes sur la base du filtrage de Git selon le code."""\n    git_filter = param.ClassSelector(class_=GitFilterModel) \n    code = param.ListSelector(default=[], objects=[])\n    df_exec = param.DataFrame(default=pd.DataFrame(), doc="DataFrame des ex\xe9cutions filtr\xe9es")\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        \n        db = pn.state.cache['db']\n        \n        # Initialisation de 'code' avec toutes les valeurs possibles dans df_commands['code']\n        all_codes = sorted(db['command']['code'].dropna().unique().tolist())\n        self.param['code'].objects = all_codes\n        self.param['code'].default = all_codes \n        self.code = all_codes\n        self._df_exec()\n    \n    @param.depends('git_filter.df_git', 'code', watch=True)\n    def _df_exec(self):\n        """\n        Filtre les executions selon le mod\xe8le (code et sha1).\n        \n        returns:   \n            DataFrame filtr\xe9e des ex\xe9cutions avec les commandes correspondantes. (avec le code issue de db['command'])\n        """\n        db = pn.state.cache['db'] \n        \n        # filtre les ex\xe9cutions par les sha1 valides du git_filter\n        df_exec = db['exec'][db['exec']['sha1'].isin(self.sha1)]     \n        \n        # filtre les commandes par les codes s\xe9lectionn\xe9s\n        commands = self.df_commands\n        \n        self.param.code.objects  = sorted(commands['code'].dropna().unique().tolist())\n        \n        \n        index_name = df_exec.index.name\n        # ajoute les command_id \xe0 exec \xe9limine les lignes sans correspondance de command_id\n        df_exec = (\n            df_exec\n            .reset_index()  \n            .merge(\n                commands[['code']],\n                left_on='Command_id',\n                right_index=True,\n                how='inner'\n            )\n            .set_index('log_hash')\n        )\n                \n        self.df_exec =  df_exec\n        self.param.trigger('df_exec')\n        \n    @property\n    def df_commands(self):\n        db = pn.state.cache['db'] \n        return db['command'][db['command']['code'].isin(self.code)]\n    \n    @property\n    def sha1(self):\n        """\n        Renvoie les sha1 s\xe9lectionn\xe9s.\n        """\n        return self.git_filter.get_sha1_valids()\n    \n    @property\n    def commands(self):\n        """Renvoie les commandes filtr\xe9es par le mod\xe8le.\n\n        Returns:\n            list: identifiants des commandes filtr\xe9es.\n        """\n        return self.df_commands.index.tolist()\n    \n    \n################################################\n## Gestion des donn\xe9es niveau 2 avec filtrage ##\n################################################\nclass Lvl2_Filter_Model(param.Parameterized):\n    command_filter = param.ClassSelector(class_=CommandFilterModel)\n    value_commands = param.List(default=[])          # liste d\u2019index (command_id) s\xe9lectionn\xe9s via les commits\n    options = param.DataFrame()             # DataFrame filtr\xe9 par le niveau 1 : index = command_id, colonnes = ['sha1', 'Config_Alias', ...]\n    value_sha1 = param.List(default=[])          # liste d\u2019index (sha1) s\xe9lectionn\xe9s via les commits\n    \n    def __init__(self, **params):\n        super().__init__(**params)\n        # On observe le DataFrame filtr\xe9 du niveau 1\n        self.value_commands = []\n        self.value_sha1 = []\n        self._update_from_lvl1()\n\n    @param.depends('command_filter.df_exec', watch=True)\n    def _update_from_lvl1(self, *events):\n        """Met \xe0 jour les options et la s\xe9lection en fonction du filtrage du niveau 1."""\n        self.options = self.command_filter.df_exec.copy().merge(\n            self.command_filter.df_commands[['Config_Alias']],\n            left_on='Command_id',\n            right_index=True,\n            how='inner'\n        )\n\n        # Nettoie la s\xe9lection courante\n        self.value_commands = list(dict.fromkeys(\n            v for v in self.value_commands if v in self.command_filter.commands\n        ))\n        \n        self.value_sha1 = list(dict.fromkeys(\n            v for v in self.value_sha1 if v in self.command_filter.sha1\n        ))\n\n    @property\n    def df_commands(self):\n        """DataFrame filtr\xe9 par le niveau 2 : index = command_id, colonnes = ['sha1', 'Config_Alias', ...]"""\n        db = pn.state.cache['db']\n        return db['command'][db['command'].index.isin(self.cross_commands)].copy()\n\n    @property\n    def cross_commands(self):\n        """Renvoie les commandes s\xe9lectionn\xe9es."""\n        return self.df_exec['Command_id'].unique().tolist()\n\n    @property\n    def cross_sha1(self):\n        """Renvoie les sha1 s\xe9lectionn\xe9s."""\n        return self.df_exec['sha1'].unique().tolist()\n\n    @property\n    def df_exec(self):\n        """DataFrame des ex\xe9cutions (runs) filtr\xe9es par le niveau 2."""\n        exec_df = self.command_filter.df_exec\n        exec_df = exec_df[exec_df['Command_id'].isin(self.value_commands)]\n        exec_df = exec_df[exec_df['sha1'].isin(self.value_sha1)]\n        return exec_df\n\n    @property\n    def df_runs(self):\n        runs = pn.state.cache['db']['runs']  \n        \n        sel = runs[runs["log_hash"].isin(self.df_exec.index)]\n        # ajoute la colonne sha1 issue du DataFrame self.df\n        sel = (\n            sel.reset_index()\n            .merge(\n                self.df_exec[['sha1', 'Command_id']],\n                left_on='log_hash',\n                right_index=True,\n                how='inner'\n            )\n            .set_index(runs.index.name)\n        )\n            \n        return sel\n\n    def reset_commands(self):\n        self.value_commands = []\n        self._update_from_lvl1()\n        \n    def reset_sha1(self):\n        self.value_sha1 = []\n        self._update_from_lvl1()\n\n##################################################\n## Gestion des donn\xe9es niveau 3 : config unique ##\n##################################################\n\nclass ConfigUniqueModel(param.Parameterized):\n    lv2_model = param.ClassSelector(default=None, class_=Lvl2_Filter_Model)\n    config = param.Selector(default=None, objects=[])\n    options = param.ListSelector(default=[], objects=[])\n\n    @property\n    def df(self):\n        if self.config is None:\n            return self.lv2_model.df_exec.iloc[0:0]  # DataFrame vide\n        return self.lv2_model.df_exec.loc[self.config]\n\n    @property\n    def df_runs(self):\n        db = pn.state.cache.get('db', {})\n        if self.config is None:\n            return pd.DataFrame()\n        return  db['runs'][db['runs']['log_hash'].isin(self.df_exec.index)]        \n \n    @property\n    def options_alias(self):\n        return self.lv2_model.df_commands['Config_Alias'].tolist()\n\n    def alias(self):\n        if self.config is None or self.config not in self.lv2_model.df_exec['Command_id'].values :\n            return None\n        return command_id_to_alias (self.config)\n\n    @param.depends('lv2_model.value_commands', 'lv2_model.value_sha1', watch=True)\n    def _on_lvl2_df_change(self):\n        # Initialise la valeur avec le command_id correspondant au premier alias\n        self.options = self.lv2_model.df_commands.index.tolist()\n\n    @property\n    def df_exec(self):\n        """Renvoie le DataFrame des ex\xe9cutions filtr\xe9es par la configuration unique."""\n        df_exec = self.lv2_model.df_exec\n        return df_exec[df_exec['Command_id'] == self.config].copy()\n    \nclass ExecUniqueModel(param.Parameterized):\n    """\n    Mod\xe8le pour g\xe9rer un ex\xe9cution unique (lot de run de SNR diff\xe9rents) d'une configuration sp\xe9cifique.\n    """\n    unique_conf_model = param.ClassSelector(class_=ConfigUniqueModel)\n    log_hash = param.Selector(default=None, objects=[])   # valeur r\xe9elle (hash)\n    trig_opt_changed = param.Event()\n\n    # Mise \xe0 jour automatique quand le mod\xe8le parent change\n    @param.depends('unique_conf_model.config', 'unique_conf_model.lv2_model.value_sha1', watch=True)\n    def _update_exec(self):\n        """Construit la liste des ex\xe9cutions disponibles et met \xe0 jour le s\xe9lecteur."""\n        df_exec = self.unique_conf_model.df_exec\n        \n        if df_exec.empty:\n            self.param['log_hash'].objects = {None: None}\n            self.log_hash = None\n        else:\n            #mise \xe0 jour des options\n            self.param['log_hash'].objects = df_exec.index.to_list()\n            # S\xe9lectionner la premi\xe8re ex\xe9cution par d\xe9faut\n            if self.log_hash is None or self.log_hash not in self.param['log_hash'].objects[0]:\n                self.log_hash = self.param['log_hash'].objects[0]    \n        self.trig_opt_changed = True\n            \n    @property\n    def df_runs(self):\n        """Renvoie le sous-ensemble des runs (SNR diff\xe9rents) pour la config s\xe9lectionn\xe9e."""\n        if self.unique_conf_model is None or self.log_hash is None:\n            return pd.DataFrame()\n        df = self.unique_conf_model.df_runs\n        return df[df['log_hash'] == self.log_hash]\n\n    @property\n    def df_tasks(self):\n        """Charge les t\xe2ches associ\xe9es \xe0 un exec unique."""\n        if self.log_hash is None:\n            return pd.DataFrame()\n\n        table_name = f"tasks/{self.log_hash}"\n        try:\n            df_tasks = load_table(table_name, fmt='json')\n            if df_tasks.empty:\n                return pd.DataFrame()\n        except Exception as e:\n            print(f"\u26a0\ufe0f Impossible de charger {table_name}: {e}")\n            return pd.DataFrame()\n\n        # Ajoute les colonnes de bruit depuis le df_runs\n        df_runs = self.df_runs\n        noise_cols = list(noise_label.values())\n\n        df_noise = df_runs[df_runs['log_hash'] == self.log_hash][noise_cols]\n        df_tasks = (df_tasks\n                    .set_index('RUN_id')\n                    .join(df_noise, how='inner')\n                    .reset_index())\n        return df_tasks\n\n    @property\n    def options(self):\n        """Liste des labels d'ex\xe9cution disponibles pour la s\xe9lection."""\n        return self.unique_conf_model.df_exec['alias'].tolist()\n\n    @property\n    def log(self):\n        """Retourne le contenu du log associ\xe9 au run_id (pas bas\xe9 sur date)."""\n        if self.log_hash is None:\n            return "\`\`\`Aucun run s\xe9lectionn\xe9.\`\`\`"\n        return f"\`\`\`\\n{self.__load_log()}\\n\`\`\`"\n\n    def __load_log(self) -> str:\n        """Lit un fichier distant h\xe9berg\xe9 sur GitLab."""\n        CHUNK = 1024 * 1024\n        url = f"{GITLAB_PACKAGE_URL}logs/{self.log_hash}.log"\n\n        headers = {"User-Agent": "Mozilla/5.0"}\n        all_data = BytesIO()\n        start = 0\n\n        while True:\n            headers["Range"] = f"bytes={start}-{start + CHUNK - 1}"\n            req = urllib.request.Request(url, headers=headers)\n            try:\n                with urllib.request.urlopen(req, timeout=None) as resp:\n                    data = resp.read()\n                    if not data:\n                        break\n                    all_data.write(data)\n                    if len(data) < CHUNK:\n                        break\n                    start += len(data)\n            except urllib.error.HTTPError as e:\n                if e.code == 416:\n                    break\n                elif e.code == 404:\n                    return "\u274c Erreur : Fichier introuvable."\n                else:\n                    return f"\u274c Erreur HTTP : {e.code} - {e.reason}"\n            except Exception as e:\n                return f"\u274c Erreur inattendue : {str(e)}"\n\n        return all_data.getvalue().decode('utf-8', errors='replace')\n\n##################################### Niveau 1 : Git et perf global ####################################\n\n#################################\n## Component pour le Panel Git ##\n#################################\nclass DateRangeFilter(pn.viewable.Viewer):\n    git_filter = param.ClassSelector(class_=GitFilterModel)\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        # Bornes extraites du DataFrame Git\n        df = pn.state.cache['db']['git']\n        \n        start, end = df['date'].min(), df['date'].max()\n        \n        # Cr\xe9ation du slider\n        self.slider = pn.widgets.DatetimeRangeSlider(\n            name='Filtre sur les dates des commits',\n            start=start,\n            end=end,\n            value=self.git_filter.date_range,\n            sizing_mode='stretch_width',\n            step = 300,\n        )\n        \n        self.slider.param.watch(\n            lambda event: setattr(self.git_filter, 'date_range', event.new),\n            'value_throttled'\n        )\n\n\n    def __panel__(self):\n        return self.slider\n\nclass PerformanceByCommit(pn.viewable.Viewer):\n    command_filter = param.ClassSelector(class_=CommandFilterModel)\n\n    def __init__(self, **params):\n        super().__init__(**params)\n\n        self.plot_throughput_pane = pn.pane.Plotly(sizing_mode='stretch_width')\n        self.plot_latency_pane = pn.pane.Plotly(sizing_mode='stretch_width')\n\n        self.tabs = pn.Tabs(\n            ('\u23f1\ufe0f Latence', self.plot_latency_pane),\n            ('\u26a1 D\xe9bit', self.plot_throughput_pane),\n            dynamic=True\n        )\n\n        self.command_filter.param.watch(self._update_all, ['df_exec'])\n\n        self._update_all()\n\n    def __panel__(self):\n        return self.tabs\n\n    def _update_all(self, *events):\n        self._update_data()\n        self._create_plots()\n\n    def _update_data(self):\n        throughput_col = 'Global throughput and elapsed time.SIM_THR(Mb/s)'\n        latency_col = 'Global throughput and elapsed time.elapse_time(ms)'\n\n        db = pn.state.cache['db']\n        df_exec = self.command_filter.df_exec\n\n        if df_exec.empty:\n            # Cr\xe9e un DataFrame vide avec colonnes attendues\n            self.df_grouped = pd.DataFrame(columns=['sha1', 'Code', 'D\xe9bit moyen (Mb/s)', 'Latence moyenne (ms)', 'date'])\n            return\n\n        df_exec = df_exec.merge(\n            db['git'][['date']], left_on='sha1', right_index=True, how='inner'\n        )\n        df = db['runs'].merge(\n            df_exec[['Command_id', 'sha1', 'date', 'code']], on='log_hash', how='left'\n        ).sort_values(by='date')\n\n        self.df_grouped = df.groupby(['sha1', 'code']).agg({\n            throughput_col: 'mean',\n            latency_col: 'mean',\n            'date': 'first'\n        }).reset_index().rename(columns={\n            throughput_col: 'D\xe9bit moyen (Mb/s)',\n            latency_col: 'Latence moyenne (ms)',\n            'code': 'Code',\n        }).sort_values(by='date')\n\n    def _create_plots(self):\n        self.plot_throughput_pane.object = px.line(\n            self.df_grouped,\n            x='date', y='D\xe9bit moyen (Mb/s)',\n            color='Code',\n            title="D\xe9bit moyen par commit (par code)",\n            markers=True\n        ).update_layout(\n            legend=dict(orientation='v', y=1, x=1.05),\n            margin=dict(r=100),\n            xaxis=dict(title="Date", rangeslider=dict(visible=True), showgrid=True),\n            yaxis=dict(title="D\xe9bit moyen (Mb/s)", showgrid=True),\n        )\n        if self.df_grouped.empty:\n            self.plot_throughput_pane.object.add_annotation(text="Aucune donn\xe9e s\xe9lectionn\xe9e",\n                                                    xref="paper", yref="paper",\n                                                    x=0.5, y=0.5, showarrow=False)\n\n\n        self.plot_latency_pane.object = px.line(\n            self.df_grouped,\n            x='date', y='Latence moyenne (ms)',\n            color='Code',\n            title="Latence moyenne par commit (par code)",\n            markers=True\n        ).update_layout(\n            legend=dict(orientation='v', y=1, x=1.05),\n            margin=dict(r=100),\n            xaxis=dict(title="Date", rangeslider=dict(visible=True), showgrid=True),\n            yaxis=dict(title="Latence moyenne (ms)", showgrid=True),\n        )\n        if self.df_grouped.empty:\n            self.plot_latency_pane.object.add_annotation(text="Aucune donn\xe9e s\xe9lectionn\xe9e",\n                                                    xref="paper", yref="paper",\n                                                    x=0.5, y=0.5, showarrow=False)\n\n\n##########################\n## S\xe9lecteur de code ##\n##########################\nclass CodeSelector(pn.viewable.Viewer):\n    cmd_filter_model = param.ClassSelector(class_=CommandFilterModel)\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        self.widget = pn.widgets.CheckBoxGroup(name='Codes \xe0 afficher', inline=True)\n        \n        db = pn.state.cache['db']\n        self.widget.options = self.cmd_filter_model.param.code.objects\n        self.widget.value = self.cmd_filter_model.param['code'].default  # Affecte la valeur par d\xe9faut des codes     \n        self.widget.param.watch(self._update_filter, 'value')\n        \n        self.select_all_button = pn.widgets.Button(name='Reset', button_type='primary', width = BUTON_WIDTH)\n        self.select_all_button.on_click(self.select_all_codes)\n\n    def select_all_codes(self, event):\n        self.widget.value = self.widget.options\n\n    def _update_filter(self, event):\n        self.cmd_filter_model.code = self.widget.value\n        \n    def __panel__(self):\n        return pn.Row(self.widget, self.select_all_button, sizing_mode="stretch_width")\n    \n##############################\n## Table des commits Git ##\n##############################\n\nclass FilteredTable(pn.viewable.Viewer):\n    filter_model = param.ClassSelector(class_=GitFilterModel)\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        self.table = pn.widgets.DataFrame(height=300, text_align='center', sizing_mode="stretch_width")\n        self._update()\n\n    @param.depends('filter_model.df_git', watch=True)\n    def _update(self, *events):\n        self.table.value = self.filter_model.df_git\n\n    def __panel__(self):\n        return self.table\n\n#####################\n## Indicateurs Git ##\n#####################\n\nclass GitIndicators(pn.viewable.Viewer):\n    filter_model = param.ClassSelector(class_=GitFilterModel)\n\n    def __init__(self, **params):\n        super().__init__(**params)\n\n        self.commit_count = pn.indicators.Number(name="Commits s\xe9lectionn\xe9s", value=0)\n        self.git_version_count = pn.indicators.Number(name="avec donn\xe9es", value=0)\n        self.last_commit_text = pn.widgets.StaticText(name="Date du dernier commit")\n\n        # \xc9coute uniquement les changements de filtre Git\n        self._update()\n\n    @param.depends('filter_model.df_git', watch=True)\n    def _update(self, *events):\n        df_filtered = self.filter_model.df_git\n        self.commit_count.value = len(df_filtered)\n        df_commands = pn.state.cache['db']['command']\n        df_exec = pn.state.cache['db']['exec']\n        if not df_filtered.empty:\n            self.git_version_count.value = df_exec[df_exec['sha1'].isin(self.filter_model.get_sha1_valids())]['sha1'].nunique()\n\n            latest_date = df_filtered['date'].max()\n            self.last_commit_text.value = latest_date.strftime('%Y-%m-%d %H:%M:%S')\n        else:\n            self.git_version_count.value = 0\n            self.last_commit_text.value = "Aucune date disponible"\n\n    def __panel__(self):\n        return pn.Row(self.commit_count, self.git_version_count, self.last_commit_text)\n\n\nclass RunsCountIndicator(pn.viewable.Viewer):\n    git_filter = param.ClassSelector(class_=GitFilterModel)\n\n    def __init__(self, **params):\n        super().__init__(**params)\n\n        # Initialisation du widget\n        self.indicator = pn.indicators.Number(\n            name="Ex\xe9cutions par pas de SNR charg\xe9s en base",\n            value=self._compute_value(),\n        )\n\n        # Met \xe0 jour automatiquement si le mod\xe8le change\n        self.git_filter.param.watch(self._update_value, 'date_range')\n\n    def _compute_value(self):\n        db = pn.state.cache.get('db')\n        return db['runs'].shape[0] if not db['runs'].empty else 0\n\n    def _update_value(self, event=None):\n        self.indicator.value = self._compute_value()\n\n    def __panel__(self):\n        return self.indicator\n\n##################################### Niveau 2 : Commandes ####################################\n\n#################################\n## S\xe9lecteur de configuration ###\n#################################\n\nMAX_SELECTION = 10\n\nclass Lvl2_ConfigPanel(pn.viewable.Viewer):\n    lv2_model = param.ClassSelector(class_=Lvl2_Filter_Model)\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        self.config_selector = pn.widgets.MultiChoice(name="S\xe9lectionnez les configurations", options=[], sizing_mode="stretch_width")\n        self.clear_button = pn.widgets.Button(name="Reset", button_type="warning", width = BUTON_WIDTH)\n        self.dialog = pn.pane.Alert(alert_type="danger", visible=False, sizing_mode="stretch_width")\n\n        self.clear_button.on_click(self.clear_configs)\n\n        self.config_selector.param.watch(self._check_selection_limit, 'value')\n        self._update_options()\n        \n    def __panel__(self):\n        return pn.Row(\n            self.config_selector,\n            self.clear_button,\n            self.dialog\n        )\n\n    @param.depends('lv2_model.options', watch=True)\n    def _update_options(self, *events):\n        options = self.lv2_model.options["Config_Alias"].tolist()\n        self.config_selector.options = options\n\n    def _check_selection_limit(self, event):\n        selected = event.new\n        if len(selected) > MAX_SELECTION:\n            self.config_selector.value = event.old\n            self.dialog.open(f"\u274c Maximum {MAX_SELECTION} configurations.")\n        else:\n            # Met \xe0 jour la liste des commandes s\xe9lectionn\xe9es dans le mod\xe8le en recup\xe9rant l'index pour l'alias\n            df = pn.state.cache['db']['command']\n            self.lv2_model.value_commands = df[df["Config_Alias"].isin(selected)].index.tolist()\n\n    def clear_configs(self, event=None):\n        self.config_selector.value = []\n\nclass Lvl2_Git_Selector(pn.viewable.Viewer):\n    lv2_model = param.ClassSelector(class_=Lvl2_Filter_Model)\n    \n    def __init__(self, **params):\n        super().__init__(**params)\n        self.git_selector = pn.widgets.MultiChoice(name="S\xe9lectionnez les commits", options=[], sizing_mode="stretch_width")\n        self.select_all_button = pn.widgets.Button(name="Tout", button_type="success" , width = BUTON_WIDTH)\n        self.clear_button = pn.widgets.Button(name="Reset", button_type="warning", width = BUTON_WIDTH)\n        self.dialog = pn.pane.Alert(alert_type="danger", visible=False, sizing_mode="stretch_width")\n\n        self.select_all_button.on_click(self.select_all_sha1)\n        self.clear_button.on_click(self.clear_sha1)\n\n        self.git_selector.param.watch(self._check_selection_limit, 'value')\n\n        self._update_options()\n        \n    def __panel__(self):\n        return pn.Row(\n            self.git_selector,\n            pn.Column(\n                self.select_all_button,\n                self.clear_button\n            ),\n            self.dialog\n        )\n\n    @param.depends('lv2_model.options', watch=True)\n    def _update_options(self, *events):\n        options = self.lv2_model.options["sha1"].unique().tolist()\n        self.git_selector.options = options\n        self.select_all_button.disabled = len(options) > MAX_SELECTION\n\n    def _check_selection_limit(self, event):\n        selected = event.new\n        if len(selected) > MAX_SELECTION:\n            self.git_selector.value = event.old\n            self.dialog.open(f"\u274c Maximum {MAX_SELECTION} configurations.")\n        else:\n            self.lv2_model.value_sha1 = selected\n\n\n    def select_all_sha1(self, event=None):\n        if len(self.git_selector.options) > MAX_SELECTION:\n            self.dialog.open(f"\u26a0\ufe0f Plus de {MAX_SELECTION} configurations. Filtrez avant de tout s\xe9lectionner.")\n        else:\n            self.git_selector.value = self.git_selector.options\n\n    def clear_sha1(self, event=None):\n        self.git_selector.value = []\n  \nclass TableConfig(pn.viewable.Viewer):\n    lvl2_model = param.ClassSelector(class_=Lvl2_Filter_Model)\n    \n    def __init__(self, **params):\n        super().__init__(**params)\n        self.tab =  pn.pane.DataFrame(self._prepare(), name='table.selected_config', index=True)\n\n    def __panel__(self):\n        return pn.Accordion( ("Configurations s\xe9lectionn\xe9es", self.tab))\n    \n    @param.depends('lvl2_model.value_commands', 'lvl2_model.value_sha1', watch=True)\n    def _update_table(self, event=None):\n        self.tab.object = self._prepare()\n\n    def _prepare(self):\n        db = pn.state.cache['db']\n        df_filtered = self.lvl2_model.df_commands[['param_id']].merge(\n            db['parameters'], \n            left_on='param_id', \n            right_index=True\n        ).drop(columns=['param_id'])\n        return df_filtered\n\n##################################### Niveau 3 : Commande ####################################\n\n# ------------------------------------------------------------------\n# Filtres des donn\xe9es niveau 3\n# ------------------------------------------------------------------\n\nclass Level3(pn.viewable.Viewer):\n    lvl2_model = param.ClassSelector(class_=Lvl2_Filter_Model)\n\n    def __init__(self, **params):\n        super().__init__(**params)\n\n        self.unique_model = ConfigUniqueModel(lv2_model=self.lvl2_model)\n\n        self.selector_command = ConfigUniqueSelector(name="One Configuration Selection", model=self.unique_model)\n\n        self.pan1 = ExecutionColumn(\n            exec_model=ExecUniqueModel(unique_conf_model=self.unique_model),\n            name="Execution 1",\n            noise_scale=noiseScale\n        )\n\n        self.pan2 = ExecutionColumn(\n            exec_model=ExecUniqueModel(unique_conf_model=self.unique_model),\n            name="Execution 2",\n            noise_scale=noiseScale\n        )\n\n        self.warning = pn.pane.Markdown("Aucune configuration s\xe9lectionn\xe9e ou aucune donn\xe9e.")\n        self.warning.visible = False  # initialement cach\xe9\n\n        self.main_panel = pn.Column(\n            self.selector_command,\n            pn.Row(self.pan1, self.pan2, sizing_mode="stretch_width"),\n            sizing_mode="stretch_width",\n            visible=False  # initialement cach\xe9\n        )\n\n        self.view = pn.Column(self.warning, self.main_panel)\n\n        # Mise \xe0 jour initiale\n        self._update_visibility()\n\n        # Lier la mise \xe0 jour \xe0 des changements\n        self.lvl2_model.param.watch(self._update_visibility, ['value_commands', 'value_sha1'])\n\n    def _update_visibility(self, *_):\n        visible = bool(self.unique_model.options)\n\n        self.main_panel.visible = visible\n        self.warning.visible = not visible\n\n    def __panel__(self):\n        return self.view\n\n\nclass ConfigUniqueSelector(pn.viewable.Viewer):\n    model = param.ClassSelector(class_=ConfigUniqueModel)\n\n    def __init__(self, **params):\n        super().__init__(**params)\n\n        # RadioBoxGroup initialis\xe9 avec les alias disponibles\n        self.selector = pn.widgets.RadioBoxGroup(\n            name='Commandes',\n            options=self.model.options_alias,\n            value=self.model.alias(),\n            inline=False\n        )\n\n        # Lorsque l'utilisateur change la s\xe9lection, on met \xe0 jour self.model.value\n        self.selector.param.watch(self._sync_model_from_selector, 'value')\n        \n    def _sync_model_from_selector(self, event):\n        """Binde la s\xe9lection (alias) vers le model.value."""\n        if event.new:\n            self.model.config = command_alias_to_command_id(event.new)\n\n    @param.depends('model.config', 'model.options', watch=True)\n    def _sync_selector_from_model(self, event=None):\n        self.selector.options  = self.model.options_alias\n        self.selector.value = self.model.alias()\n        if self.selector.value is None:\n            self.selector.value = self.model.options_alias[0] if self.model.options_alias else None\n        \n    def __panel__(self):\n        return pn.Column(\n            pn.pane.Markdown("**Choisir une commandes :**"),\n            self.selector\n        )\n\nclass ExecUniqueSelector(pn.viewable.Viewer):\n    execUniqueModel = param.ClassSelector(default=None, class_=ExecUniqueModel)\n\n    def __init__(self, **params):\n        super().__init__(**params)\n\n        self._syncing = False  # \xe9vite les boucles de synchronisation\n\n        self.exec_selector = pn.widgets.Select(\n            name="Choisir une ex\xe9cution",\n            options=[],\n        )\n        self._sync_selector_from_model()\n        self.exec_selector.param.watch(self._sync_model_from_selector, "value")\n\n    @param.depends('execUniqueModel.log_hash', 'execUniqueModel.trig_opt_changed', watch=True)\n    def _sync_selector_from_model(self):\n        """Synchronise le widget avec le mod\xe8le."""\n        if self._syncing:\n            return\n\n        self._syncing = True\n        try:\n            label_map = self.execUniqueModel.options\n            self.exec_selector.options = self.execUniqueModel.options\n            self.exec_selector.value = exec_log_hash_to_alias(self.execUniqueModel.log_hash) if self.execUniqueModel.log_hash else None\n\n        finally:\n            self._syncing = False\n\n    def _sync_model_from_selector(self, event):\n        """Met \xe0 jour le mod\xe8le \xe0 partir de la s\xe9lection utilisateur."""\n        if self._syncing or self.execUniqueModel is None:\n            return\n\n        self._syncing = True\n        try:\n            selected_label = event.new\n            self.execUniqueModel.log_hash = exec_alias_to_log_hash(selected_label)\n        finally:\n            self._syncing = False\n\n    def __panel__(self):\n        return self.exec_selector\n\n# ------------------------------------------------------------------\n# Affichage d'une execution\n# ------------------------------------------------------------------\nclass ExecutionColumn(pn.viewable.Viewer):\n    def __init__(self, name, exec_model, noise_scale, **params):\n        super().__init__(**params)\n\n        # S\xe9lecteur d'ex\xe9cution\n        self.exec_selector = ExecUniqueSelector(name=name, execUniqueModel=exec_model)\n\n        # Histogramme des t\xe2ches\n        self.histogram = Tasks_Histogramme(\n            unique_exec_model=exec_model,\n            noiseScale=noise_scale\n        )\n\n        # Visualiseur de logs\n        self.log_viewer = LogViewer(execUniqueModel=exec_model)\n\n        self.layout = pn.Column(\n            self.exec_selector,\n            self.histogram,\n            pn.pane.HTML(f"<h3> \u270f\ufe0f Logs - {name}</h3>"),\n            self.log_viewer,\n            sizing_mode="stretch_width"\n        )\n\n    def __panel__(self):\n        return self.layout\n    \n# ------------------------------------------------------------------\n# Affichage des journeaux d'exec\n# ------------------------------------------------------------------\nclass LogViewer(pn.viewable.Viewer):\n    execUniqueModel = param.ClassSelector(default=None, class_=ExecUniqueModel)\n    \n    def __init__(self, **params):\n        super().__init__(**params) \n        self.output_pane = pn.pane.Markdown("S\xe9lectionnez une configuration pour voir les fichiers.")\n\n    @param.depends('execUniqueModel.log_hash', watch=True)\n    def _update_log(self, event=None):\n        self.output_pane.object = self.execUniqueModel.log\n\n    def __panel__(self):\n        # Affichage du s\xe9lecteur et des onglets\n        return self.output_pane\n\n# ------------------------------------------------------------------\n# Graphe des t\xe2ches\n# ------------------------------------------------------------------\nclass Tasks_Histogramme(pn.viewable.Viewer):\n    # Param\xe8tres configurables\n    unique_exec_model = param.ClassSelector(class_=ExecUniqueModel, doc="Selecteur de configurations uniques")\n    noiseScale = param.ClassSelector(class_=NoiseScale, doc="Choix de l'\xe9chelle de bruit par passage du label de la colonne")\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        self.button_time_perc = pn.widgets.Toggle(name='\u23f1', value=False)\n        self.button_time_perc.param.watch(self.changeIcon, 'value')\n        self.ListBouton = pn.Column(\n            pn.widgets.TooltipIcon(value="Affichage des temps des t\xe2ches en milli-seconde ou en %."), \n            self.button_time_perc,\n            width=50)\n        self.graphPanel = pn.bind(self._plot_task_data, self.button_time_perc, self.unique_exec_model.param.log_hash, self.noiseScale.param.value)\n        \n    def changeIcon(self, event) :\n        if event.new : \n            self.button_time_perc.name = '%'\n        else :\n            self.button_time_perc.name = '\u23f1'\n    \n    def __panel__(self):\n        return pn.Row(self.ListBouton, self.graphPanel)\n    \n    def _plot_task_data(self, percent, index, noiseKey):\n        if index is None :\n            return pn.pane.Markdown(f"Histogramme des t\xe2ches : S\xe9lectionner une configuration pour afficher.")\n        df = self.unique_exec_model.df_tasks\n\n        if df.empty:\n            self.button_time_perc.disabled = True\n            return pn.pane.Markdown(f"Histogramme des t\xe2ches : Pas de donn\xe9es de t\xe2ches disponibles pour l'execution de la configuration s\xe9lectionn\xe9e.")\n        else:\n            self.button_time_perc.disabled = False\n            \n        if percent:\n            y_label = ('Time', 'Dur\xe9e')\n        else:\n            y_label = ('Perc', 'Dur\xe9e (%)')\n        \n        # Pivot des donn\xe9es pour que chaque combinaison Signal Noise Ratio(SNR).Eb/N0(dB) ait des colonnes pour les temps des t\xe2ches\n        pivot_df = df.pivot_table(\n            values=y_label[0], \n            index=[noiseKey], \n            columns='Task',\n            aggfunc='sum', \n            fill_value=0\n        )\n\n        # G\xe9n\xe9rer une palette de couleurs automatiquement selon le nombre de configurations\n        colors = px.colors.qualitative.Plotly[:len(index) * len(df['Task'].unique())]\n\n        # Initialiser la figure Plotly\n        fig = go.Figure()\n        \n        # Ajouter chaque t\xe2che comme une barre empil\xe9e\n        for task in pivot_df.columns:\n            fig.add_trace(go.Bar(\n                x=pivot_df.index.map(lambda x: f"SNR: {x}"),  # SNR comme \xe9tiquette\n                y=pivot_df[task],\n                name=task\n            ))\n\n        # Configuration de la mise en page\n        fig.update_layout(\n            barmode='stack',\n            title=f"Temps des t\xe2ches par Configuration et Niveau de Bruit  : {noiseKey}",\n            xaxis_title="Niveau de Bruit",\n            yaxis_title=y_label[1],\n            xaxis=dict(tickangle=25),  # Rotation des \xe9tiquettes de l'axe x\n            template="plotly_white",\n            height=900,\n            showlegend=True,\n            margin=dict(t=70, b=50, l=50, r=10)\n        )\n        return pn.pane.Plotly(fig, sizing_mode="stretch_width")\n\n# ------------------------------------------------------------------\n# Performance BER/FER par niveau de bruit (lvl2)\n# ------------------------------------------------------------------\nclass PerformanceBERFERPlot(pn.viewable.Viewer):\n    lvl2_model = param.ClassSelector(class_=Lvl2_Filter_Model, doc="Mod\xe8le de filtrage de niveau 2")\n    noise_scale_param = param.ClassSelector(class_=NoiseScale, doc="Param\xe8tre de niveau de bruit")\n    \n    def __init__(self, **params):\n        super().__init__(**params)\n        self.plot_pane = pn.pane.Plotly(sizing_mode="stretch_width")\n        self.view = self.plot_pane\n\n        # Initialisation + lien des callbacks\n        self._update_plot()\n        self.lvl2_model.param.watch(self._update_plot, ['value_commands', 'value_sha1'])\n        self.noise_scale_param.param.watch(self._update_plot, ['value'])\n\n    def __panel__(self):\n        return self.view\n\n    def _update_plot(self, *_):\n        df_runs = self.lvl2_model.df_runs\n        \n        if df_runs.empty:\n\n            fig = go.Figure()\n            fig.add_annotation(\n                text="\u26a0\ufe0f Aucune ex\xe9cution s\xe9lectionn\xe9e ou disponible.",\n                xref="paper", yref="paper",\n                x=0.5, y=0.5, showarrow=False,\n                font=dict(size=20),\n                align="center"\n            )\n            fig.update_layout(\n                template="plotly_white",\n                xaxis=dict(visible=False),\n                yaxis=dict(visible=False),\n                height=600\n            )\n            self.plot_pane.object = fig\n            return\n\n        noiseScale = self.noise_scale_param.value\n        df_runs = df_runs.sort_values(by=noiseScale, ascending=True)\n\n        # Ajouter la colonne cl\xe9 (couple Command_id + sha1)\n        df_runs['cmd_sha'] = (\n            df_runs['Command_id'].astype(str) + ' - ' +\n            df_runs['sha1'].str[:7]\n        )\n\n        grouped = df_runs.groupby('cmd_sha')\n        colors = px.colors.qualitative.Plotly[:len(grouped)]\n\n        fig = go.Figure()\n\n        for (key, grp), color in zip(grouped, colors):\n            snr = grp[noiseScale]\n            ber = grp['Bit Error Rate (BER) and Frame Error Rate (FER).BER']\n            fer = grp['Bit Error Rate (BER) and Frame Error Rate (FER).FER']\n\n            # Trace BER (ligne pleine avec marqueurs)\n            fig.add_trace(go.Scatter(\n                x=snr, y=ber,\n                mode='lines+markers',\n                name=f"BER - {key}",\n                line=dict(width=2, color=color),\n                marker=dict(symbol='circle', size=6)\n            ))\n\n            # Trace FER (ligne pointill\xe9e avec marqueurs)\n            fig.add_trace(go.Scatter(\n                x=snr, y=fer,\n                mode='lines+markers',\n                name=f"FER - {key}",\n                line=dict(width=2, dash='dash', color=color),\n                marker=dict(symbol='x', size=6)\n            ))\n\n        \n        # Configuration de la mise en page avec Range Slider et Range Selector\n        fig.update_layout(\n            title="BER et FER en fonction du SNR pour chaque couple (Command, Commit)",\n            xaxis=dict(\n                title=f"Niveau de Bruit (SNR) : {noiseScale}",\n                rangeslider=dict(visible=True),\n                rangeselector=dict(\n                    buttons=[\n                        dict(count=1, label="1dB", step="all", stepmode="backward"),\n                        dict(count=5, label="5dB", step="all", stepmode="backward"),\n                        dict(count=10, label="10dB", step="all", stepmode="backward"),\n                        dict(step="all")\n                    ]\n                )\n            ),\n            yaxis=dict(title="Taux d'Erreur", type='log'),\n            legend_title="Command - Commit",\n            template="plotly_white",\n            height=600,\n            showlegend=True,\n            margin=dict(t=70, b=50, l=50, r=10)\n        )\n\n        self.plot_pane.object = fig\n\n\n# ------------------------------------------------------------------\n# Assemblage du panel git\n# ------------------------------------------------------------------\nclass PanelCommit(pn.viewable.Viewer):\n    \n    command_filter = param.ClassSelector(default=None, class_=CommandFilterModel, doc="Filtre de commandes")\n    git_filter = param.ClassSelector(default=None, class_=GitFilterModel, doc="Filtre Git")\n    \n    def __init__(self, **params):\n        super().__init__(**params)\n        # Initialisation du tableau de commandes\n        self.date_slider    = DateRangeFilter(git_filter=self.git_filter)\n        # Composants construits\n        self.code_selector = CodeSelector(cmd_filter_model=self.command_filter)\n        self.table = FilteredTable(filter_model=self.git_filter)\n        db = pn.state.cache['db']\n        self.indicators = GitIndicators(filter_model=self.git_filter)\n        self.perfgraph = PerformanceByCommit(command_filter=self.command_filter)\n\n    def __panel__(self):\n        return pn.Column(\n            self.indicators,\n            self.date_slider,\n            self.table,\n            self.code_selector,\n            self.perfgraph,\n            sizing_mode="stretch_width"\n        )\n\n    def update_command_table(self, event=None):\n        self.command_table.value = self.command_filter.df_git\n\n# ------------------------------------------------------------------\n# Param\xeatre du site\n# ------------------------------------------------------------------\nnoiseScale = NoiseScale(noise_label= noise_label)\n\n# ------------------------------------------------------------------\n# Point d\u2019entr\xe9e unique\n# ------------------------------------------------------------------\n\ndef main():\n    print(ud.unidata_version)\n    load_data_sync()\n    for k, v in pn.state.cache['db'].items():\n        print(f"{k:8s} : {len(v):6d} lignes")\n    template = init_dashboard()\n    template.servable()\n\nif IS_PANEL_CONVERT:\n    # GitHub-Pages (pyodide-worker) \u2192 on charge et on sert\n    main()\n\nelif IS_PYODIDE:\n    # JupyterLite ou autre environnement Pyodide \u2192 onload\n    pn.state.onload(lambda: main())\n\nelse:\n    # Mode local \xab python dashboard_commit.py \xbb\n    load_data_sync()\n    for k, v in pn.state.cache['db'].items():\n        print(f"{k:8s} : {len(v):6d} lignes")\n    dashboard = init_dashboard()\n    dashboard.show(port=35489)\n\nawait write_doc()
  `

  try {
    const [docs_json, render_items, root_ids] = await self.pyodide.runPythonAsync(code)
    self.postMessage({
      type: 'render',
      docs_json: docs_json,
      render_items: render_items,
      root_ids: root_ids
    })
  } catch(e) {
    const traceback = `${e}`
    const tblines = traceback.split('\n')
    self.postMessage({
      type: 'status',
      msg: tblines[tblines.length-2]
    });
    throw e
  }
}

self.onmessage = async (event) => {
  const msg = event.data
  if (msg.type === 'rendered') {
    self.pyodide.runPythonAsync(`
    from panel.io.state import state
    from panel.io.pyodide import _link_docs_worker

    _link_docs_worker(state.curdoc, sendPatch, setter='js')
    `)
  } else if (msg.type === 'patch') {
    self.pyodide.globals.set('patch', msg.patch)
    self.pyodide.runPythonAsync(`
    from panel.io.pyodide import _convert_json_patch
    state.curdoc.apply_json_patch(_convert_json_patch(patch), setter='js')
    `)
    self.postMessage({type: 'idle'})
  } else if (msg.type === 'location') {
    self.pyodide.globals.set('location', msg.location)
    self.pyodide.runPythonAsync(`
    import json
    from panel.io.state import state
    from panel.util import edit_readonly
    if state.location:
        loc_data = json.loads(location)
        with edit_readonly(state.location):
            state.location.param.update({
                k: v for k, v in loc_data.items() if k in state.location.param
            })
    `)
  }
}

startApplication()