importScripts("https://cdn.jsdelivr.net/pyodide/v0.27.0/full/pyodide.js");

function sendPatch(patch, buffers, msg_id) {
  self.postMessage({
    type: 'patch',
    patch: patch,
    buffers: buffers
  })
}

async function startApplication() {
  console.log("Loading pyodide!");
  self.postMessage({type: 'status', msg: 'Loading pyodide'})
  self.pyodide = await loadPyodide();
  self.pyodide.globals.set("sendPatch", sendPatch);
  console.log("Loaded!");
  await self.pyodide.loadPackage("micropip");
  const env_spec = ['https://cdn.holoviz.org/panel/wheels/bokeh-3.6.0-py3-none-any.whl', 'https://cdn.holoviz.org/panel/1.6.0/dist/wheels/panel-1.6.0-py3-none-any.whl', 'pyodide-http==0.2.1', 'pandas', 'param', 'plotly', 'pyarrow']
  for (const pkg of env_spec) {
    let pkg_name;
    if (pkg.endsWith('.whl')) {
      pkg_name = pkg.split('/').slice(-1)[0].split('-')[0]
    } else {
      pkg_name = pkg
    }
    self.postMessage({type: 'status', msg: `Installing ${pkg_name}`})
    try {
      await self.pyodide.runPythonAsync(`
        import micropip
        await micropip.install('${pkg}');
      `);
    } catch(e) {
      console.log(e)
      self.postMessage({
	type: 'status',
	msg: `Error while installing ${pkg_name}`
      });
    }
  }
  console.log("Packages loaded!");
  self.postMessage({type: 'status', msg: 'Executing code'})
  const code = `
  \nimport asyncio\n\nfrom panel.io.pyodide import init_doc, write_doc\n\ninit_doc()\n\nfrom bokeh.settings import settings\nsettings.resources = 'inline'\n\nimport pandas as pd\nimport panel as pn\nfrom datetime import datetime\nimport argparse\nimport re\nimport plotly.graph_objs as go\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport param\nfrom panel.viewable import Viewer\nimport unicodedata as ud\nimport itertools\nfrom io import BytesIO\nimport sys\nimport os\nimport unicodedata as ud\nimport urllib.request\nimport json\n\ntry:\n    import pyarrow.parquet as pq\nexcept ImportError:\n    pq = None\n\n# ------------------------------------------------------------------------------\n#  Variables d\u2019environnement\n# ------------------------------------------------------------------------------\nIS_PYODIDE       = sys.platform == "emscripten"\nIS_PANEL_CONVERT = os.getenv("PANEL_CONVERT") == "1"\n\n# ------------------------------------------------------------------------------\n#  Chargement des donn\xe9es \u2013 SYNCHRONE\n# ------------------------------------------------------------------------------\n\ndef load_table(name: str, fmt: str = "parquet") -> pd.DataFrame:\n    GITLAB_PACKAGE_URL = "https://gitlab.inria.fr/api/v4/projects/1420/packages/generic/gitlab-elk-export/latest/"\n    url = f"{GITLAB_PACKAGE_URL}{name}.{fmt}"\n    CHUNK = 1024 * 1024          # 1 Mo par appel\n\n    headers = {\n        "User-Agent": "Mozilla/5.0",\n        "Accept-Encoding": "identity"   # d\xe9sactive la compression bricol\xe9e\n    }\n\n    all_data = BytesIO()\n    start = 0\n\n    while True:\n        headers["Range"] = f"bytes={start}-{start + CHUNK - 1}"\n        req = urllib.request.Request(url, headers=headers)\n        try:\n            with urllib.request.urlopen(req, timeout=None) as resp:\n                data = resp.read()\n                if not data:          # plus rien\n                    break\n                all_data.write(data)\n                if len(data) < CHUNK: # dernier morceau\n                    break\n                start += len(data)\n        except urllib.error.HTTPError as e:\n            if e.code == 416:         # Range Not Satisfiable \u2192 fin atteinte\n                break\n            else:\n                raise\n\n    all_data.seek(0)\n    if fmt == "json":\n        return pd.read_json(all_data, lines=True)\n    elif fmt == "parquet":\n        return pd.read_parquet(all_data)\n    else:\n        return pd.DataFrame()\n\ndef load_data_sync() -> None:\n    """Charge toutes les tables dans pn.state.cache['db'] (synchrone)."""\n    print("\u2699\ufe0f load_data_sync() appel\xe9")\n    if IS_PYODIDE or IS_PANEL_CONVERT:\n        fmt='json'\n    else:    \n        fmt = 'parquet'\n    \n    df_commands = load_table('command', fmt)\n    print("1/6 command charg\xe9")\n    df_param = load_table('parameters', fmt)\n    print("2/6 parameters charg\xe9")\n    df_tasks = load_table('tasks', fmt)\n    print("3/6 tasks charg\xe9")\n    df_runs = load_table('runs', fmt)\n    print("4/6 runs charg\xe9")\n    df_git = load_table('git', fmt)\n    print("5/6 git charg\xe9")\n    df_log = load_table('logs', fmt)\n    print("6/6 logs charg\xe9")\n\n    if df_commands.empty:\n        raise ValueError("Impossible de charger les donn\xe9es pour 'command'. Veuillez v\xe9rifier l'URL et les d\xe9pendances.")\n    df_commands.set_index('Command_id', inplace=True)\n\n    df_param.set_index('param_id', inplace=True)\n    df_tasks.set_index('RUN_id', inplace=True)\n    df_runs.set_index('RUN_id', inplace=True)\n    df_git.set_index('sha1', inplace=True)\n    df_log.set_index('Log_id', inplace=True)\n\n    # Alias\n    df_commands['Config_Alias'] = (\n        df_commands.index.astype(str) + " : " +\n        df_commands['Command_short'].astype(str) + "_" +\n        df_commands['sha1'].astype(str)\n    )\n\n    pn.state.cache['db'] = {\n        "commands": df_commands,\n        "tasks": df_tasks,\n        "runs": df_runs,\n        "git": df_git,\n        "param": df_param,\n        "logs": df_log,\n        "config_aliases": dict(zip(df_commands.index, df_commands['Config_Alias']))\n    }\n\n    apply_typing_code()\n    print("\u2705 load_data_sync() termin\xe9")\n    \n# ------------------------------------------------------------------------------\n#  Typage automatique (copi\xe9-coll\xe9 de la version JSON)\n# ------------------------------------------------------------------------------\n\ndef apply_typing_code():\n    ''' Applique le typage des donn\xe9es  (copier coller du r\xe9sultat de generate_typing_code) ''' \n    # Typage pour commands\n    commands = pn.state.cache['db']['commands']\n    commands['Command'] = commands['Command'].astype(str)\n    commands['sha1'] = commands['sha1'].astype(str)\n    commands['Command_short'] = commands['Command_short'].astype(str)\n    commands['param_id'] = commands['param_id'].astype(str)\n    commands['Config_Alias'] = commands['Config_Alias'].astype(str)\n    pn.state.cache['db']['commands'] = commands\n\n    # Typage pour tasks\n    tasks = pn.state.cache['db']['tasks']\n    pn.state.cache['db']['tasks'] = tasks\n\n    # Typage pour runs\n    runs = pn.state.cache['db']['runs']\n    runs['log_hash'] = runs['log_hash'].astype(str)\n    runs['Date_Execution'] = pd.to_datetime(runs['Date_Execution'], errors='coerce')\n    runs['Bit Error Rate (BER) and Frame Error Rate (FER).BE'] = pd.to_numeric(runs['Bit Error Rate (BER) and Frame Error Rate (FER).BE'], errors='coerce').astype('Int64')\n    runs['Bit Error Rate (BER) and Frame Error Rate (FER).BER'] = pd.to_numeric(runs['Bit Error Rate (BER) and Frame Error Rate (FER).BER'], errors='coerce')\n    runs['Bit Error Rate (BER) and Frame Error Rate (FER).FE'] = pd.to_numeric(runs['Bit Error Rate (BER) and Frame Error Rate (FER).FE'], errors='coerce').astype('Int64')\n    runs['Bit Error Rate (BER) and Frame Error Rate (FER).FER'] = pd.to_numeric(runs['Bit Error Rate (BER) and Frame Error Rate (FER).FER'], errors='coerce')\n    runs['Bit Error Rate (BER) and Frame Error Rate (FER).FRA'] = pd.to_numeric(runs['Bit Error Rate (BER) and Frame Error Rate (FER).FRA'], errors='coerce').astype('Int64')\n    runs['Global throughputand elapsed time.SIM_THR(Mb/s)'] = pd.to_numeric(runs['Global throughputand elapsed time.SIM_THR(Mb/s)'], errors='coerce')\n    runs['Global throughputand elapsed time.elapse_time(ns)'] = pd.to_numeric(runs['Global throughputand elapsed time.elapse_time(ns)'], errors='coerce')\n    runs['Signal Noise Ratio(SNR).Eb/N0(dB)'] = pd.to_numeric(runs['Signal Noise Ratio(SNR).Eb/N0(dB)'], errors='coerce')\n    runs['Signal Noise Ratio(SNR).Es/N0(dB)'] = pd.to_numeric(runs['Signal Noise Ratio(SNR).Es/N0(dB)'], errors='coerce')\n    runs['Signal Noise Ratio(SNR).Sigma'] = pd.to_numeric(runs['Signal Noise Ratio(SNR).Sigma'], errors='coerce')\n    runs['source.type'] = runs['source.type'].astype(str)\n    runs['id'] = runs['id'].astype(str)\n    runs['url'] = runs['url'].astype(str)\n    runs['status'] = runs['status'].astype(str)\n    runs['job_id'] = runs['job_id'].astype(str)\n    runs['job_name'] = runs['job_name'].astype(str)\n    runs['Signal Noise Ratio(SNR).Event Probability'] = pd.to_numeric(runs['Signal Noise Ratio(SNR).Event Probability'], errors='coerce')\n    runs['Mutual Information.MI'] = pd.to_numeric(runs['Mutual Information.MI'], errors='coerce')\n    runs['Mutual Information.MI_max'] = pd.to_numeric(runs['Mutual Information.MI_max'], errors='coerce')\n    runs['Mutual Information.MI_min'] = pd.to_numeric(runs['Mutual Information.MI_min'], errors='coerce')\n    runs['Mutual Information.n_trials'] = pd.to_numeric(runs['Mutual Information.n_trials'], errors='coerce')\n    runs['Signal Noise Ratio(SNR).Received Optical'] = pd.to_numeric(runs['Signal Noise Ratio(SNR).Received Optical'], errors='coerce')\n    runs['Command_id'] = runs['Command_id'].astype(str)\n    pn.state.cache['db']['runs'] = runs\n\n    # Typage pour git\n    git = pn.state.cache['db']['git']\n    git['author'] = git['author'].astype(str)\n    git['email'] = git['email'].astype(str)\n    git['date'] = pd.to_datetime(git['date'], errors='coerce')\n    git['message'] = git['message'].astype(str)\n    git['insertions'] = pd.to_numeric(git['insertions'], errors='coerce').astype('Int64')\n    git['deletions'] = pd.to_numeric(git['deletions'], errors='coerce').astype('Int64')\n    git['files_changed'] = pd.to_numeric(git['files_changed'], errors='coerce').astype('Int64')\n    pn.state.cache['db']['git'] = git\n\n    # Typage pour param\n    param = pn.state.cache['db']['param']\n    param['Channel.Add users'] = param['Channel.Add users'].astype(str)\n    param['Channel.Complex'] = param['Channel.Complex'].astype(str)\n    param['Channel.Implementation'] = param['Channel.Implementation'].astype(str)\n    param['Channel.Type'] = param['Channel.Type'].astype(str)\n    param['Codec.Code rate'] = param['Codec.Code rate'].astype(str)\n    param['Codec.Codeword size (N_cw)'] = param['Codec.Codeword size (N_cw)'].astype(str)\n    param['Codec.Frame size (N)'] = param['Codec.Frame size (N)'].astype(str)\n    param['Codec.Info. bits (K)'] = param['Codec.Info. bits (K)'].astype(str)\n    param['Codec.Type'] = param['Codec.Type'].astype(str)\n    param['Decoder.Correction power (T)'] = param['Decoder.Correction power (T)'].astype(str)\n    param['Decoder.Galois field order (m)'] = param['Decoder.Galois field order (m)'].astype(str)\n    param['Decoder.Implementation'] = param['Decoder.Implementation'].astype(str)\n    param['Decoder.Systematic'] = param['Decoder.Systematic'].astype(str)\n    param['Decoder.Type (D)'] = param['Decoder.Type (D)'].astype(str)\n    param['Encoder.Systematic'] = param['Encoder.Systematic'].astype(str)\n    param['Encoder.Type'] = param['Encoder.Type'].astype(str)\n    param['Modem.Bits per symbol'] = param['Modem.Bits per symbol'].astype(str)\n    param['Modem.Implementation'] = param['Modem.Implementation'].astype(str)\n    param['Modem.Sigma square'] = param['Modem.Sigma square'].astype(str)\n    param['Modem.Type'] = param['Modem.Type'].astype(str)\n    param['Monitor.Compute mutual info'] = param['Monitor.Compute mutual info'].astype(str)\n    param['Monitor.Frame error count (e)'] = param['Monitor.Frame error count (e)'].astype(str)\n    param['Monitor.Lazy reduction'] = param['Monitor.Lazy reduction'].astype(str)\n    param['Simulation.Bad frames replay'] = param['Simulation.Bad frames replay'].astype(str)\n    param['Simulation.Bad frames tracking'] = param['Simulation.Bad frames tracking'].astype(str)\n    param['Simulation.Bit rate'] = param['Simulation.Bit rate'].astype(str)\n    param['Simulation.Code type (C)'] = param['Simulation.Code type (C)'].astype(str)\n    param['Simulation.Coded monitoring'] = param['Simulation.Coded monitoring'].astype(str)\n    param['Simulation.Coset approach (c)'] = param['Simulation.Coset approach (c)'].astype(str)\n    param['Simulation.Date (UTC)'] = param['Simulation.Date (UTC)'].astype(str)\n    param['Simulation.Debug mode'] = param['Simulation.Debug mode'].astype(str)\n    param['Simulation.Git version'] = param['Simulation.Git version'].astype(str)\n    param['Simulation.Inter frame level'] = param['Simulation.Inter frame level'].astype(str)\n    param['Simulation.Json export'] = param['Simulation.Json export'].astype(str)\n    param['Simulation.Multi-threading (t)'] = param['Simulation.Multi-threading (t)'].astype(str)\n    param['Simulation.Noise range'] = param['Simulation.Noise range'].astype(str)\n    param['Simulation.Noise type (E)'] = param['Simulation.Noise type (E)'].astype(str)\n    param['Simulation.Seed'] = param['Simulation.Seed'].astype(str)\n    param['Simulation.Statistics'] = param['Simulation.Statistics'].astype(str)\n    param['Simulation.Type'] = param['Simulation.Type'].astype(str)\n    param['Simulation.Type of bits'] = param['Simulation.Type of bits'].astype(str)\n    param['Simulation.Type of reals'] = param['Simulation.Type of reals'].astype(str)\n    param['Source.Implementation'] = param['Source.Implementation'].astype(str)\n    param['Source.Info. bits (K_info)'] = param['Source.Info. bits (K_info)'].astype(str)\n    param['Source.Type'] = param['Source.Type'].astype(str)\n    param['Terminal.Enabled'] = param['Terminal.Enabled'].astype(str)\n    param['Terminal.Frequency (ms)'] = param['Terminal.Frequency (ms)'].astype(str)\n    param['Terminal.Show Sigma'] = param['Terminal.Show Sigma'].astype(str)\n    param['Quantizer.Fixed-point config.'] = param['Quantizer.Fixed-point config.'].astype(str)\n    param['Quantizer.Implementation'] = param['Quantizer.Implementation'].astype(str)\n    param['Quantizer.Type'] = param['Quantizer.Type'].astype(str)\n    param['Simulation.Type of quant. reals'] = param['Simulation.Type of quant. reals'].astype(str)\n    param['Decoder.H matrix path'] = param['Decoder.H matrix path'].astype(str)\n    param['Decoder.H matrix reordering'] = param['Decoder.H matrix reordering'].astype(str)\n    param['Decoder.Num. of iterations (i)'] = param['Decoder.Num. of iterations (i)'].astype(str)\n    param['Decoder.Stop criterion (syndrome)'] = param['Decoder.Stop criterion (syndrome)'].astype(str)\n    param['Decoder.Stop criterion depth'] = param['Decoder.Stop criterion depth'].astype(str)\n    param['Decoder.Weighting factor'] = param['Decoder.Weighting factor'].astype(str)\n    param['Encoder.G build method'] = param['Encoder.G build method'].astype(str)\n    param['Encoder.H matrix path'] = param['Encoder.H matrix path'].astype(str)\n    param['Encoder.H matrix reordering'] = param['Encoder.H matrix reordering'].astype(str)\n    param['Decoder.Bernouilli probas'] = param['Decoder.Bernouilli probas'].astype(str)\n    param['CRC.Implementation'] = param['CRC.Implementation'].astype(str)\n    param['CRC.Polynomial (hexadecimal)'] = param['CRC.Polynomial (hexadecimal)'].astype(str)\n    param['CRC.Size (in bit)'] = param['CRC.Size (in bit)'].astype(str)\n    param['CRC.Type'] = param['CRC.Type'].astype(str)\n    param['Decoder.Adaptative mode'] = param['Decoder.Adaptative mode'].astype(str)\n    param['Decoder.Max num. of lists (L)'] = param['Decoder.Max num. of lists (L)'].astype(str)\n    param['Decoder.Polar node types'] = param['Decoder.Polar node types'].astype(str)\n    param['Decoder.SIMD strategy'] = param['Decoder.SIMD strategy'].astype(str)\n    param['Frozen bits generator.Noise'] = param['Frozen bits generator.Noise'].astype(str)\n    param['Frozen bits generator.Type'] = param['Frozen bits generator.Type'].astype(str)\n    param['Puncturer.Type'] = param['Puncturer.Type'].astype(str)\n    param['Decoder.Node type'] = param['Decoder.Node type'].astype(str)\n    param['Frozen bits generator MK.Noise'] = param['Frozen bits generator MK.Noise'].astype(str)\n    param['Frozen bits generator MK.Type'] = param['Frozen bits generator MK.Type'].astype(str)\n    param['Polar code.Kernel'] = param['Polar code.Kernel'].astype(str)\n    param['Decoder.Min type'] = param['Decoder.Min type'].astype(str)\n    param['Interleaver.Seed'] = param['Interleaver.Seed'].astype(str)\n    param['Interleaver.Type'] = param['Interleaver.Type'].astype(str)\n    param['Interleaver.Uniform'] = param['Interleaver.Uniform'].astype(str)\n    param['Encoder.Buffered'] = param['Encoder.Buffered'].astype(str)\n    param['Polar code.Kernels'] = param['Polar code.Kernels'].astype(str)\n    param['Polar code.Stages'] = param['Polar code.Stages'].astype(str)\n    param['Puncturer.Pattern'] = param['Puncturer.Pattern'].astype(str)\n    param['Codec.Symbols Codeword size'] = param['Codec.Symbols Codeword size'].astype(str)\n    param['Codec.Symbols Source size'] = param['Codec.Symbols Source size'].astype(str)\n    param['Decoder.Max type'] = param['Decoder.Max type'].astype(str)\n    param['Decoder.Polynomials'] = param['Decoder.Polynomials'].astype(str)\n    param['Decoder.Standard'] = param['Decoder.Standard'].astype(str)\n    param['Encoder.Polynomials'] = param['Encoder.Polynomials'].astype(str)\n    param['Encoder.Standard'] = param['Encoder.Standard'].astype(str)\n    param['Encoder.Tail length'] = param['Encoder.Tail length'].astype(str)\n    param['Decoder.Num. of lists (L)'] = param['Decoder.Num. of lists (L)'].astype(str)\n    param['Decoder.Normalize factor'] = param['Decoder.Normalize factor'].astype(str)\n    param['Source.Auto reset'] = param['Source.Auto reset'].astype(str)\n    param['Source.Fifo mode'] = param['Source.Fifo mode'].astype(str)\n    param['Source.Path'] = param['Source.Path'].astype(str)\n    param['Flip and check.Enabled'] = param['Flip and check.Enabled'].astype(str)\n    param['Scaling factor.Enabled'] = param['Scaling factor.Enabled'].astype(str)\n    param['Scaling factor.SF iterations'] = param['Scaling factor.SF iterations'].astype(str)\n    param['Scaling factor.Scaling factor (SF)'] = param['Scaling factor.Scaling factor (SF)'].astype(str)\n    param['Flip and check.FNC ite max'] = param['Flip and check.FNC ite max'].astype(str)\n    param['Flip and check.FNC ite min'] = param['Flip and check.FNC ite min'].astype(str)\n    param['Flip and check.FNC ite step'] = param['Flip and check.FNC ite step'].astype(str)\n    param['Flip and check.FNC q'] = param['Flip and check.FNC q'].astype(str)\n    param['Modem.Max type'] = param['Modem.Max type'].astype(str)\n    param['Frozen bits generator.Path'] = param['Frozen bits generator.Path'].astype(str)\n    param['Modem.Codebook'] = param['Modem.Codebook'].astype(str)\n    param['Modem.Number of iterations'] = param['Modem.Number of iterations'].astype(str)\n    param['Modem.Psi function'] = param['Modem.Psi function'].astype(str)\n    param['Interleaver.Number of columns'] = param['Interleaver.Number of columns'].astype(str)\n    param['Channel.Block fading policy'] = param['Channel.Block fading policy'].astype(str)\n    param['Modem.CPM L memory'] = param['Modem.CPM L memory'].astype(str)\n    param['Modem.CPM h index'] = param['Modem.CPM h index'].astype(str)\n    param['Modem.CPM mapping'] = param['Modem.CPM mapping'].astype(str)\n    param['Modem.CPM sampling factor'] = param['Modem.CPM sampling factor'].astype(str)\n    param['Modem.CPM standard'] = param['Modem.CPM standard'].astype(str)\n    param['Modem.CPM wave shape'] = param['Modem.CPM wave shape'].astype(str)\n    param['Decoder.Num. of flips'] = param['Decoder.Num. of flips'].astype(str)\n    param['Interleaver.Path'] = param['Interleaver.Path'].astype(str)\n    param['Simulation.Global iterations (I)'] = param['Simulation.Global iterations (I)'].astype(str)\n    param['Modem.ROP estimation'] = param['Modem.ROP estimation'].astype(str)\n    param['Simulation.PDF path'] = param['Simulation.PDF path'].astype(str)\n    pn.state.cache['db']['param'] = param\n\n    # Typage pour logs\n    logs = pn.state.cache['db']['logs']\n    logs['log'] = logs['log'].astype(str)\n    logs['hash'] = logs['hash'].astype(str)\n    logs['filename'] = logs['filename'].astype(str)\n    logs['Date_Execution'] = logs['Date_Execution'].astype(str)\n    pn.state.cache['db']['logs'] = logs\n\ndef generate_typing_code(df, df_name="df"):\n    ''' G\xe9n\xe8re du code Python ex\xe9cutable pour forcer le typage des colonnes dans pn.state.cache["db"][df_name] '''\n    lines = [\n        f"# Typage pour {df_name}",\n        f"{df_name} = pn.state.cache['db']['{df_name}']"\n    ]\n    \n    for col in df.columns:\n        dtype = df[col].dtype\n\n        if pd.api.types.is_integer_dtype(dtype):\n            lines.append(f"{df_name}['{col}'] = pd.to_numeric({df_name}['{col}'], errors='coerce').astype('Int64')")\n        elif pd.api.types.is_float_dtype(dtype):\n            lines.append(f"{df_name}['{col}'] = pd.to_numeric({df_name}['{col}'], errors='coerce')")\n        elif pd.api.types.is_bool_dtype(dtype):\n            lines.append(f"{df_name}['{col}'] = {df_name}['{col}'].astype(bool)")\n        elif pd.api.types.is_datetime64_any_dtype(dtype):\n            lines.append(f"{df_name}['{col}'] = pd.to_datetime({df_name}['{col}'], errors='coerce')")\n        else:\n            lines.append(f"{df_name}['{col}'] = {df_name}['{col}'].astype(str)")\n\n    # R\xe9assigner dans le cache (non strictement n\xe9cessaire mais plus explicite)\n    lines.append(f"pn.state.cache['db']['{df_name}'] = {df_name}")\n\n    return "\\n".join(lines)\n\n# ------------------------------------------------------------------------------\n#  Initialisation du dashboard\n# ------------------------------------------------------------------------------\ndef init_dashboard():\n    print("\u2699\ufe0f init_dashboard() appel\xe9")\n\n    db = pn.state.cache['db']\n\n    git_filter = GitFilterModel(df_git=db['git'])\n\n    merged_df = db['commands'].merge(\n        db['param'][['Simulation.Code type (C)']],\n        left_on='param_id', right_index=True, how='left'\n    )\n    merged_df.rename(columns={'Simulation.Code type (C)': 'code'}, inplace=True)\n\n    command_filter = CommandFilterModel(df_commands=merged_df, git_filter=git_filter)\n\n    panelCommit = PanelCommit(command_filter=command_filter, git_filter=git_filter)\n\n    lvl2_filter = Lvl2_Filter_Model(command_filter=command_filter)\n    config_panel = ConfigPanel(lv2_model=lvl2_filter)\n\n    mi_panel = pn.Column(\n        Mutual_information_Panels(lv2_model=lvl2_filter, noiseScale=noiseScale),\n        scroll=True, height=700\n    )\n\n    panelConfig = pn.Row(\n        pn.Column(\n            config_panel,\n            TableConfig(lv2_filter=lvl2_filter, meta=False),\n            pn.Tabs(\n                ('BER/FER', pn.bind(plot_performance_metrics_plotly,\n                                   lvl2_filter.param.value, noiseScale.param.value)),\n                ('Mutual information', mi_panel)\n            ),\n            sizing_mode="stretch_width"\n        )\n    )\n\n    unique_model = ConfigUniqueModel(lv2_model=lvl2_filter)\n\n    panel_par_config = pn.Column(\n        pn.pane.HTML("<h3> \u270f\ufe0f Logs</h3>"),\n        LogViewer(unique_conf_model=unique_model),\n        sizing_mode="stretch_width"\n    )\n\n    config_count = pn.indicators.Number(\n        name="Configurations en base",\n        value=db['commands'].shape[0] if not db['commands'].empty else 0\n    )\n\n    panelData = pn.Column(config_count, sizing_mode="stretch_width")\n\n    dashboard = pn.Column(\n        pn.pane.HTML("<h2>\u270f\ufe0f Niveau 1 : Evolution par commit</h2>"),\n        panelCommit,\n        pn.pane.HTML("<h2>\u260e\ufe0f Niveau 2 : BER / FER</h2>"),\n        panelConfig,\n        pn.pane.HTML("<h2>\u2699\ufe0f Niveau 3 : Analyse \xe0 la commande</h2>"),\n        panel_par_config,\n        sizing_mode="stretch_width"\n    )\n\n    logo = pn.pane.Image(\n        "https://raw.githubusercontent.com/fCheminadeInria/aff3ct.github.io/"\n        "refs/heads/master/comit_dashboard/image/93988066-1f77-4b42-941f-1d5ef89ddca2.webp",\n        width=200\n    )\n\n    template = pn.template.FastListTemplate(\n        title="Commits Dashboard",\n        sidebar=[logo, noiseScale, pn.layout.Divider(), panelData],\n        main=[dashboard],\n        main_layout=None,\n        accent="teal",\n        theme_toggle=False,\n    )\n\n    print("\u2705 init_dashboard() termin\xe9")\n    return template\n\n##################################### Niveau Global ####################################\n\nIS_PYODIDE       = sys.platform == "emscripten"\nIS_PANEL_CONVERT = os.getenv("PANEL_CONVERT") == "1"\n\n# Initialiser Panel\npn.extension(\n    "plotly", \n    sizing_mode="stretch_width", \n    )\n\n##################################### Variable statiques ####################################\nnoise_label = {\n    'Eb/N0': 'Signal Noise Ratio(SNR).Eb/N0(dB)',\n    'Es/N0': 'Signal Noise Ratio(SNR).Es/N0(dB)',\n    'Sigma': 'Signal Noise Ratio(SNR).Sigma',\n}\n\n######################\n## Echelle de bruit ##\n######################\n\nclass NoiseScale (pn.viewable.Viewer) :\n    value = param.String(default= 'Signal Noise Ratio(SNR).Eb/N0(dB)', allow_refs=True)\n    noise_label = param.Dict()\n    \n    def __init__ (self, **params):\n        super().__init__(**params)\n        \n        self.radio_group = pn.widgets.RadioBoxGroup(\n            name='Echelle de bruit', \n            options=list(self.noise_label.keys()), \n            value=list(self.noise_label.keys())[0], \n            inline=True )\n        self._update_value(None)\n        self.radio_group.param.watch(self._update_value, "value")\n\n    def __panel__(self):\n        return pn.Column(\n            pn.pane.Markdown(f"**{self.radio_group.name} :** "),\n            pn.Row(self.radio_group, css_classes=["align-right"],sizing_mode="stretch_width"),\n            sizing_mode="stretch_width")\n\n    def _update_value(self, event):\n        """\n        Met \xe0 jour la propri\xe9t\xe9 \`value\` en fonction de la s\xe9lection.\n        """\n        self.value = self.noise_label[self.radio_group.value]\n\n##################################### Mod\xe8le de donn\xe9es ####################################\n\n##################################\n## Gestion des donn\xe9es niveau 1 ##\n##################################\n\nclass GitFilterModel(param.Parameterized):\n    df_git = param.DataFrame()\n    date_range = param.Tuple(default=(None, None), length=2, doc="Plage de dates pour filtrer")\n    filtered = param.Parameter()\n\n    @param.depends('date_range', watch=True)\n    def _trigger(self):\n        self.param.trigger('filtered')\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        # Si date_range n'est pas fourni, on initialise avec la plage compl\xe8te des dates\n        if self.date_range == (None, None):\n            min_date = self.df_git['date'].min()\n            max_date = self.df_git['date'].max()\n            self.date_range = (min_date, max_date)\n\n    def get_filtered_df(self):\n        df = self.df_git.copy()\n        start, end = self.date_range\n        if start and end:\n            start = start\n            end   = end\n            df = df[(df['date'] >= start) & (df['date'] <= end)]\n        return df\n    \n    def get_sha1_valids(self):\n        return self.get_filtered_df().index.unique()\n\nclass CommandFilterModel(param.Parameterized):\n    df_commands = param.DataFrame()\n    git_filter = param.ClassSelector(class_=GitFilterModel) \n    code = param.ListSelector(default=[], objects=[])\n    filtered = param.Parameter() # variable pour d\xe9clencher le filtrage\n    config_filter = param.Dict(default={})\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        # Initialisation de 'code' avec toutes les valeurs possibles dans df_commands['code']\n        all_codes = sorted(self.df_commands['code'].dropna().unique().tolist())\n        self.param['code'].objects = all_codes\n        self.param['code'].default = all_codes \n        self.code = all_codes\n\n    @param.depends('config_filter', 'code', 'git_filter.filtered', watch=True)\n    def _trigger(self):\n        self.param.trigger('filtered')  \n\n    def get_filtered_df(self):\n        sha1_valids = self.git_filter.get_sha1_valids()\n        df_filtered = self.df_commands[self.df_commands['sha1'].isin(sha1_valids)]\n        if 'All' not in self.code:\n            df_filtered = df_filtered[df_filtered['code'].isin(self.code)]\n        self.df_commands_intermediare = df_filtered\n        for col, values in self.config_filter.items():\n            if values:\n                df_filtered = df_filtered[df_filtered[col].isin(values)]\n        return df_filtered\n\nclass Research_config_filter(pn.viewable.Viewer):\n    command_filter = param.ClassSelector(class_=CommandFilterModel)\n\n    def __init__(self, **params):\n        super().__init__(**params)\n\n        df = self.command_filter.get_filtered_df()\n        df_filtered = df.drop(columns=['Config_Alias', 'param_id', 'meta_id', 'git_id', 'Command', 'Simulation.Code type (C)'], errors='ignore')\n\n        # Identification des familles de param\xe8tres\n        family_columns = {}\n        for col in df_filtered.columns:\n            match = re.match(r"(\\w+)\\.(\\w+)", col)\n            if match:\n                family_columns.setdefault(match.group(1), []).append(col)\n            else:\n                family_columns.setdefault("Autres", []).append(col)\n\n        # Cr\xe9ation des widgets de filtrage\n        family_widgets = {}\n        for family, columns in family_columns.items():\n            widgets = []\n            for col in columns:\n                options = sorted(df[col].dropna().unique().tolist())\n                is_disabled = len(options) <= 1\n                widget = pn.widgets.MultiChoice(\n                    name=col,\n                    options=options,\n                    value=options,\n                    disabled=is_disabled,\n                    css_classes=["grayed-out"] if is_disabled else []\n                )\n                widget.param.watch(self._update_filterconfig, 'value')\n                widgets.append(widget)\n            family_widgets[family] = pn.Column(*widgets, name=family)\n\n        self.accordion_families = pn.Accordion(*[(f"{family}", widget) for family, widget in family_widgets.items()])\n        \n        self.filtre_actif= pn.pane.Markdown("", height=100)\n        self._config_filter_to_markdown()\n        \n        self.command_filter.param.watch(self._update_filter, 'filtered')\n\n    def _config_filter_to_markdown(self) -> str:\n        parts = []\n        for col_container in self.accordion_families.objects:\n            for widget in col_container.objects:\n                all_options = widget.options\n                selected = widget.value\n                deselected = sorted(set(all_options) - set(selected))\n                if deselected:\n                    parts.append(f"**{widget.name}** : {', '.join(map(str, deselected))}")\n\n        self.filtre_actif.object =  "\\n\\n".join(parts) if parts else "_Aucun filtre d\xe9sactiv\xe9_"\n        \n    def __panel__(self):\n        \n        return pn.Card(\n            pn.Column(\n                pn.Card(\n                    pn.Column(\n                        self.filtre_actif, \n                        styles={'overflow-y': 'auto'}\n                        ),\n                    title="\U0001f50d Filtres actifs"\n                    ),\n                self.accordion_families, \n                height=400,\n                styles={'overflow-y': 'auto'}),\n                title="\U0001f50d Filtres de recherche",\n                collapsed=False\n                )\n            \n    def _get_current_filter(self):\n        """Construit un dictionnaire {colonne: valeurs s\xe9lectionn\xe9es} pour le filtre."""\n        return {\n            widget.name: widget.value\n            for col in self.accordion_families.objects\n            for widget in col.objects\n            if widget.value  # Ne garde que les filtres actifs\n        }\n\n    def _update_filter(self, event):\n        df = self.command_filter.get_filtered_df()\n        if df is None or df.empty:\n            return\n\n        # Appliquer le filtre actuel sur df_commands pour avoir le df filtr\xe9\n        df_filtered = df.drop(columns=['Config_Alias', 'param_id', 'meta_id', 'git_id', 'Command', 'Simulation.Code type (C)'], errors='ignore')\n\n        # Appliquer le filtre config_filter (ex: garder uniquement les valeurs s\xe9lectionn\xe9es pour chaque colonne)\n        for col, selected_values in self.command_filter.config_filter.items():\n            if selected_values:\n                df_filtered = df_filtered[df_filtered[col].isin(selected_values)]\n\n        # Met \xe0 jour les options et \xe9ventuellement les valeurs des widgets\n        for col_container in self.accordion_families.objects:\n            for widget in col_container.objects:\n                if widget.name in df_filtered.columns:\n                    options = sorted(self.command_filter.df_commands_intermediare[widget.name].dropna().unique().tolist())\n                    widget.options = options\n\n                    # Si la s\xe9lection actuelle n'est plus dans les options, on remet toute la s\xe9lection possible\n                    if not set(widget.value).issubset(set(options)):\n                        widget.value = options if options else []\n\n    def _update_filterconfig(self, event):\n        """Met \xe0 jour le filtre du mod\xe8le lors d\u2019un changement utilisateur."""\n        \n        # Emp\xeache la suppression compl\xe8te des options\n        if len(event.new) < 1:\n            event.obj.value = event.old\n            return\n\n        self.command_filter.config_filter = {**self.command_filter.config_filter,    event.obj.name: event.new}\n        self._config_filter_to_markdown()\n\n################################################\n## Gestion des donn\xe9es niveau 2 avec filtrage ##\n################################################\n\nclass Lvl2_Filter_Model(param.Parameterized):\n    command_filter = param.ClassSelector(class_=CommandFilterModel)\n    value = param.List(default=[])\n    df = param.DataFrame()\n    options = param.DataFrame(default=pd.DataFrame(columns=["Config_Alias"]), doc="DataFrame contenant les options de filtrage")\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        self._update_df()\n        self._update_from_lvl1()\n        self.command_filter.param.watch(self._update_from_lvl1, 'filtered')\n        self.param.watch(self._update_df, 'value')\n        \n    def _update_from_lvl1(self, *events):\n        df_filtered = self.command_filter.get_filtered_df()\n        self.value = [v for v in self.value if v in df_filtered.index]\n        self.options = df_filtered[['Config_Alias']]\n\n    @property\n    def df_runs_filtred(self):\n        df_runs = pn.state.cache['db']['runs']\n        df_runs = df_runs[df_runs["Command_id"].isin(self.value)]\n        return  df_runs\n            \n    def _update_df(self, *events):\n        self.df = self.command_filter.get_filtered_df().loc[self.value]     \n     \n    def reset(self):\n        self.value = []\n\n##################################################\n## Gestion des donn\xe9es niveau 3 : config unique ##\n##################################################\n\nclass ConfigUniqueModel(param.Parameterized):\n    lv2_model = param.ClassSelector(default=None, class_=Lvl2_Filter_Model)\n    value = param.Selector(default=None, objects=[])\n    date = param.Selector(default=None, objects=[])\n    options = param.Selector(default=None, objects=[])\n\n    @property\n    def _df_configs_from_lvl2(self):\n        """Acc\xe8s s\xe9curis\xe9 au DataFrame."""\n        return self.lv2_model.df if self.lv2_model is not None else pd.DataFrame()\n\n    @property\n    def df(self):\n        if self.value is None:\n            return self._df_configs_from_lvl2.iloc[0:0]  # DataFrame vide\n        return self._df_configs_from_lvl2.loc[self.value]\n\n    @property\n    def df_runs(self):\n        db = pn.state.cache.get('db', {})\n        if 'runs' not in db or self.value is None:\n            return pd.DataFrame()\n        return  db['runs'][db['runs']['Command_id']== self.value]        \n\n    @property\n    def df_logs(self):\n        db = pn.state.cache.get('db', {})\n        if 'logs' not in db or self.value is None:\n            return pd.DataFrame()\n        df_logs = db['logs']\n        log_hash = self.df_runs['log_hash'].unique() if not self.df_runs.empty else []\n        return  df_logs[df_logs['hash'].isin(log_hash)]\n\n    @property\n    def log(self):\n        df_logs = self.df_logs\n        if self.date is None or df_logs.empty:\n            return "\`\`\`Pas de logs pour la s\xe9lection.\`\`\`"\n        \n        match = df_logs[df_logs['Date_Execution'] == self.date]\n        if match.empty:\n            return "\`\`\`Aucun log trouv\xe9 pour cette date.\`\`\`"\n        \n        if 'log' in match.columns:\n            # Encapsuler le log dans un bloc de code Markdown\n            contenu = match.iloc[0]['log']\n            return f"\`\`\`\\n{contenu}\\n\`\`\`"\n        else:\n            return "\`\`\`Colonne 'log' manquante.\`\`\`"\n\n    @param.depends('value', watch=True)\n    def _update_date(self):\n        if 'hash' in self.df_logs.columns :\n            self.date = self.df_logs['Date_Execution'].iloc[0]\n        else:\n            self.date = None\n            \n    @property\n    def options_dates(self):\n        """Liste des dates d'ex\xe9cution disponibles pour la configuration s\xe9lectionn\xe9e."""\n        df_logs = self.df_logs\n        if df_logs.empty or 'Date_Execution' not in df_logs.columns:\n            return []\n        # Conversion en str pour l'affichage (utile pour un widget Select)\n        return df_logs['Date_Execution'].astype(str).unique().tolist()\n \n    @property\n    def options_alias(self):\n        return self._df_configs_from_lvl2['Config_Alias'].tolist()\n\n    def _find_id_by_alias(self, alias):\n        df = self._df_configs_from_lvl2\n        if df.empty or 'Config_Alias' not in df.columns:\n            return None\n        matched = df.index[df['Config_Alias'] == alias]\n        return matched[0] if len(matched) > 0 else None\n\n    def alias(self):\n        if self.value is None or self.value not in self._df_configs_from_lvl2.index:\n            return '-'\n        return self._df_configs_from_lvl2.at[self.value, 'Config_Alias']\n\n    def value_by_alias(self, alias):\n        id = self._find_id_by_alias(alias)\n        if id is not None:\n            self.value = id\n\n    @param.depends('lv2_model.df', watch=True)\n    def _on_lvl2_df_change(self):\n        opts = self._df_configs_from_lvl2.index.tolist()\n        # Initialise la valeur avec le command_id correspondant au premier alias\n        if self.value not in opts :\n            self.value = opts[0] if opts else None\n        self.options = opts\n\n\n##################################### Niveau 1 : Git et perf global ####################################\n\n#################################\n## Component pour le Panel Git ##\n#################################\nclass DateRangeFilter(pn.viewable.Viewer):\n    git_filter = param.ClassSelector(class_=GitFilterModel)\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        # Bornes extraites du DataFrame Git\n        db = pn.state.cache['db']\n        df = db ['git']\n        \n        start, end = df['date'].min(), df['date'].max()\n        \n        # Forcer la plage de dates dans le mod\xe8le si elle est incorrecte ou absente\n        if not hasattr(self.git_filter, 'date_range') or self.git_filter.date_range is None:\n            self.git_filter.date_range = (start, end)\n        \n        # Cr\xe9ation du slider\n        self.slider = pn.widgets.DatetimeRangeSlider(\n            name='Filtre sur les dates des commits',\n            start=start,\n            end=end,\n            value=(start, end),\n            sizing_mode='stretch_width',\n            step = 300,\n        )\n        self.slider.param.watch( lambda event: setattr(self.git_filter, 'date_range', event.new),'value')\n\n    def __panel__(self):\n        return self.slider\n\nclass PerformanceByCommit(pn.viewable.Viewer):\n    git_filter = param.ClassSelector(class_=GitFilterModel)\n    command_filter = param.ClassSelector(class_=CommandFilterModel)\n    \n    def __init__(self, **params):\n        super().__init__(**params)\n\n        self.git_filter.param.watch(self._update_all, 'filtered')\n        self.command_filter.param.watch(self._update_all, 'filtered')\n        \n        self.plot_throughput_pane = pn.pane.Plotly(sizing_mode='stretch_width')\n        self.plot_latency_pane = pn.pane.Plotly(sizing_mode='stretch_width')\n        \n        df_commands = self.command_filter.df_commands\n        \n        db = pn.state.cache['db']\n        \n        # filtrage sur les commandes restantes et ajouts des colonnes de date\n        df = db['runs'][db['runs']['Command_id'].isin(df_commands.index)].merge(\n           df_commands[['sha1', 'code']], left_on='Command_id', right_index=True\n        ).merge(\n            db['git'][['date']], left_on='sha1', right_index=True\n        ).reset_index(drop=True)\n        \n        self.df = df.sort_values(by=['date'])\n        \n        self._update_all()\n        \n        self.tabs = pn.Tabs(\n            ('\u23f1\ufe0f Latence', self.plot_latency_pane),\n            ('\U0001f4c8 D\xe9bit', self.plot_throughput_pane),\n        )\n        \n    def _update_all(self, *events):\n        self._update_data()\n        self._create_plots()\n        self.plot_throughput_pane.object = self.fig_throughput\n        self.plot_latency_pane.object = self.fig_latency\n\n    def _update_data(self):\n\n        df = self.df[\n            (self.df['sha1'].isin(self.git_filter.get_filtered_df().index)) &\n            (self.df['Command_id'].isin(self.command_filter.get_filtered_df().index))\n        ]\n        \n        # Aggr\xe9gation des donn\xe9es par commit et par type de code\n        throughput_col = 'Global throughputand elapsed time.SIM_THR(Mb/s)'\n        latency_col = 'Global throughputand elapsed time.elapse_time(ns)'\n        \n        self.df_grouped = df.groupby(['sha1', 'code']).agg({\n            throughput_col: 'mean',\n            latency_col: 'mean',\n            'date': 'first'\n        }).reset_index().rename(columns={\n            throughput_col: 'D\xe9bit moyen (Mb/s)',\n            latency_col: 'Latence moyenne (ns)',\n            'code' : 'Code',\n        }).sort_values(by=['date'])\n\n    def _create_plots(self):\n        self.fig_throughput = px.line(\n            self.df_grouped,\n            x='date', y='D\xe9bit moyen (Mb/s)',\n            color='Code',\n            title="D\xe9bit moyen par commit (par code)",\n            markers=True\n        )\n        self.fig_throughput.update_layout(\n            legend=dict(orientation='v', y=1, x=1.05),\n            margin=dict(r=100),\n            xaxis=dict(title="Date", rangeslider=dict(visible=True), showgrid=True),\n            yaxis=dict(title="D\xe9bit moyen (Mb/s)", showgrid=True),\n        )\n\n        self.fig_latency = px.line(\n            self.df_grouped,\n            x='date', y='Latence moyenne (ns)',\n            color='Code',\n            title="Latence moyenne par commit (par code)",\n            markers=True\n        )\n        self.fig_latency.update_layout(\n            legend=dict(orientation='v', y=1, x=1.05),\n            margin=dict(r=100),\n            xaxis=dict(title="Date", rangeslider=dict(visible=True), showgrid=True),\n            yaxis=dict(title="Latence moyenne (ns)", showgrid=True),\n        )\n\n    def __panel__(self):\n        return self.tabs\n\n##########################\n## S\xe9lecteur de code ##\n##########################\nclass CodeSelector(pn.viewable.Viewer):\n    cmd_filter_model = param.ClassSelector(class_=CommandFilterModel)\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        self.widget = pn.widgets.CheckBoxGroup(name='Codes \xe0 afficher', inline=True)\n        \n        db = pn.state.cache['db']\n        self.widget.options = sorted(db['param']['Simulation.Code type (C)'].fillna('Non d\xe9fini').unique().tolist())\n        self.cmd_filter_model.param['code'].objects = self.widget.options   \n        self.widget.value = self.cmd_filter_model.param['code'].default  # Affecte la valeur par d\xe9faut des codes     \n        # self.widget.param.watch(self._update_filter, 'value')\n        \n        self.select_all_button = pn.widgets.Button(name='S\xe9lectionner tout', button_type='primary')\n        self.select_all_button.on_click(self.select_all_codes)\n        \n        self.deselect_all_button = pn.widgets.Button(name='D\xe9s\xe9lectionner tout', button_type='danger')\n        self.deselect_all_button.on_click(self.deselect_all_codes)\n        \n        self.apply_button = pn.widgets.Button(name='Appliquer les filtres', button_type='success') \n        self.apply_button.on_click(self._update_filter) \n\n        self.spinner = pn.indicators.LoadingSpinner(value=False, width=25)\n        \n    def select_all_codes(self, event):\n        self.widget.value = self.widget.options\n\n    def deselect_all_codes(self, event):\n        self.widget.value = []\n\n    def _update_filter(self, event):\n        self.cmd_filter_model.code = self.widget.value\n        \n        self.spinner.value = True\n\n        try:\n            self.cmd_filter_model.code = self.widget.value\n        finally:\n            self._set_interactive(True)\n            self.spinner.value = False\n\n    def _set_interactive(self, active: bool):\n        """Active ou d\xe9sactive les interactions"""\n        self.widget.disabled = not active\n        self.select_all_button.disabled = not active\n        self.deselect_all_button.disabled = not active\n        self.apply_button.disabled = not active\n\n    def __panel__(self):\n        return pn.Row(self.select_all_button, self.deselect_all_button, self.widget, self.apply_button, self.spinner)\n    \n##############################\n## Table des commits Git ##\n##############################\n\nclass FilteredTable(pn.viewable.Viewer):\n    filter_model = param.ClassSelector(class_=GitFilterModel)\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        self.table = pn.widgets.DataFrame(height=300, text_align='center', sizing_mode="stretch_width")\n        self._update()\n        self.filter_model.param.watch(self._update, ['filtered'])\n\n    def _update(self, *events):\n        self.table.value = self.filter_model.get_filtered_df()\n\n    def __panel__(self):\n        return self.table\n\n#####################\n## Indicateurs Git ##\n#####################\n\nclass GitIndicators(pn.viewable.Viewer):\n    filter_model = param.ClassSelector(class_=GitFilterModel)\n\n    def __init__(self, df_git, df_commands, **params):\n        super().__init__(**params)\n        self.df_git = df_git\n        self.df_commands = df_commands\n\n        self.commit_count = pn.indicators.Number(name="Commits historis\xe9s dans Git", value=0)\n        self.git_version_count = pn.indicators.Number(name="Commits avec des donn\xe9es", value=0)\n        self.last_commit_text = pn.widgets.StaticText(name="Date du dernier commit")\n\n        # \xc9coute uniquement les changements de filtre Git\n        self.filter_model.param.watch(self._update, 'filtered')\n        self._update()\n\n    def _update(self, *events):\n        df_filtered = self.filter_model.get_filtered_df()\n        self.commit_count.value = len(df_filtered)\n\n        if not df_filtered.empty:\n            valid_sha1 = df_filtered.index\n            count_valid_sha1 = self.df_commands[self.df_commands['sha1'].isin(valid_sha1)]['sha1'].nunique()\n            self.git_version_count.value = count_valid_sha1\n\n            latest_date = df_filtered['date'].max()\n            self.last_commit_text.value = latest_date.strftime('%Y-%m-%d %H:%M:%S')\n        else:\n            self.git_version_count.value = 0\n            self.last_commit_text.value = "Aucune date disponible"\n\n    def __panel__(self):\n        return pn.Row(self.commit_count, self.git_version_count, self.last_commit_text)\n\n\n##################################### Niveau 2 : Commandes ####################################\n\n#################################\n## S\xe9lecteur de configuration ###\n#################################\n\nMAX_SELECTION = 10\n\nclass ConfigPanel(pn.viewable.Viewer):\n    lv2_model = param.ClassSelector(class_=Lvl2_Filter_Model)\n\n    def __init__(self, **params):\n        super().__init__(**params)\n\n        self.config_selector = pn.widgets.MultiChoice(name="S\xe9lectionnez les configurations", options=[])\n        self.select_all_button = pn.widgets.Button(name="Tout s\xe9lectionner", button_type="success")\n        self.clear_button = pn.widgets.Button(name="Tout d\xe9s\xe9lectionner", button_type="warning")\n        self.dialog = pn.pane.Alert(alert_type="danger", visible=False, sizing_mode="stretch_width")\n\n        self.select_all_button.on_click(self.select_all_configs)\n        self.clear_button.on_click(self.clear_configs)\n\n        self.config_selector.param.watch(self._check_selection_limit, 'value')\n        self.lv2_model.param.watch(self._update_options, 'options')\n        self._update_options()\n        \n    def __panel__(self):\n        return pn.Column(\n            self.select_all_button,\n            self.clear_button,\n            self.config_selector,\n            self.dialog\n        )\n\n    def _update_options(self, *events):\n        options = self.lv2_model.options["Config_Alias"].tolist()\n        self.config_selector.options = options\n        self.select_all_button.disabled = len(options) > MAX_SELECTION\n\n    def _check_selection_limit(self, event):\n        selected = event.new\n        if len(selected) > MAX_SELECTION:\n            self.config_selector.value = event.old\n            self.dialog.open(f"\u274c Maximum {MAX_SELECTION} configurations.")\n        else:\n            self.lv2_model.value = self.lv2_model.options[self.lv2_model.options["Config_Alias"].isin(selected)].index.tolist()\n\n    def select_all_configs(self, event=None):\n        if len(self.config_selector.options) > MAX_SELECTION:\n            self.dialog.open(f"\u26a0\ufe0f Plus de {MAX_SELECTION} configurations. Filtrez avant de tout s\xe9lectionner.")\n        else:\n            self.config_selector.value = self.config_selector.options\n\n    def clear_configs(self, event=None):\n        self.config_selector.value = []\n      \n# affichage de la s\xe9lection     \nclass TableConfig(pn.viewable.Viewer):\n    lv2_filter = param.ClassSelector(class_=Lvl2_Filter_Model)\n    meta = param.Boolean(doc="affiche les Meta-donn\xe9es si Vrai, les param\xe8tres de simmulation si faux")\n    \n    def __init__(self, **params):\n        super().__init__(**params)\n        self.tab =  pn.pane.DataFrame(self._prepare(), name='table.selected_config', index=True)\n        self.lv2_filter.param.watch(self._update_table, 'value')\n\n    def __panel__(self):\n        return pn.Accordion( ("\U0001f4e5 Selected Configuration", self.tab))\n    \n    def _update_table(self, event=None):\n        self.tab.object = self._prepare()\n\n    def _prepare(self):\n        db = pn.state.cache['db']\n        if self.meta :\n            df_filtered = self.lv2_filter.df[['meta_id']] .merge(db['meta'] , left_on='meta_id',  right_index=True).drop(columns=['meta_id'])\n        else :\n            df_filtered = self.lv2_filter.df[['param_id']].merge(db['param'], left_on='param_id', right_index=True).drop(columns=['param_id'])\n        return df_filtered\n\nclass Panel_graph_envelope(pn.viewable.Viewer):\n    # Param\xe8tres configurables\n    df = param.DataFrame(doc="Le dataframe contenant les donn\xe9es")\n    lab = param.String(default="y", doc="Nom de la colonne pour l'axe Y")\n    lab_group = param.String(default=None, doc="Nom de la colonne pour regrouper les donn\xe9es")\n    labmin = param.String(default=None, doc="Nom de la colonne pour la valeur minimale")\n    labmax = param.String(default=None, doc="Nom de la colonne pour la valeur maximale")\n    Ytitle = param.String(default="Valeur", doc="Titre de l'axe Y")\n    noiseScale = param.ClassSelector(default=None, class_=pn.viewable.Viewer,doc="Choix de l'\xe9chelle de bruit par passage du label de la colonne")\n    lv2_model = param.ClassSelector(default=None, class_=Lvl2_Filter_Model, doc="Mod\xe8le de filtrage de niveau 2")\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        \n        self.button_env = pn.widgets.Toggle(name='\u303d\ufe0f', value=True)\n        \n        if (self.labmin == None or self.labmax == None):\n            self.button_env.value=False\n            self.button_env.disabled=True\n        \n        self.ListBouton = pn.Column(\n            pn.widgets.TooltipIcon(value="Activer/D\xe9sactiver Enveloppe"), \n            self.button_env,\n            width=50)\n        self.graphPanel = pn.bind(self._plot_enveloppe_incertitude,self.button_env, self.noiseScale.param.value)\n        \n\n    def __panel__(self):\n        return pn.Row(self.ListBouton, self.graphPanel)\n        \n    def _plot_enveloppe_incertitude(self, show_envelope, noiseKey):    \n        \n        index = self.lv2_model.value\n        \n        if index is None :\n            df_filtred = self.df\n        else :\n            df_filtred = self.df[self.df["Command_id"].isin(index)] \n        \n        # Si pas de donn\xe9es de t\xe2ches pour les configurations s\xe9lectionn\xe9es\n        if df_filtred.empty:\n            self.button_env.disabled=True\n            if self.lab_group :\n                return pn.pane.Markdown(f"Graphes de {self.Ytitle} : Pas de donn\xe9es de {self.lab_group} disponibles pour les configurations s\xe9lectionn\xe9es.")\n            else :\n                return pn.pane.Markdown(f"Graphes de {self.Ytitle} : Pas de donn\xe9es disponibles pour les configurations s\xe9lectionn\xe9es.")\n        else :\n            self.button_env.disabled=False\n            \n        if (self.labmin == None or self.labmax == None):\n            show_envelope = False\n        \n        color_cycle = itertools.cycle(px.colors.qualitative.Plotly)\n        fig = go.Figure()\n\n        # Ajouter une trace pour chaque configuration et t\xe2che\n        for i, config in enumerate(index):\n            # Filtrer les donn\xe9es pour chaque configuration\n            config_data = df_filtred[df_filtred['Command_id'] == config]\n            \n            db = pn.state.cache['db']\n            alias = db['commands'].loc[config, 'Config_Alias'] #variable global pas propre mais commode\n            if self.lab_group :\n                for j, t in enumerate(config_data[self.lab_group].unique()):  \n                    task_data = config_data[config_data[self.lab_group] == t]\n                    snr = task_data[noiseKey]\n                    y_values = task_data[self.lab]         \n                    color = next(color_cycle)\n\n                    if show_envelope :\n                        y_values_min = task_data[self.labmin]  \n                        y_values_max = task_data[self.labmax]   \n                        \n                        # Courbe pour la latence avec enveloppe\n                        fig.add_trace(go.Scatter(\n                            x=snr, y=y_values_max,\n                            fill=None, mode='lines+markers',\n                            line=dict(width=2, dash='dash', color=color),\n                            marker=dict(symbol='x', size=6),\n                            showlegend=False\n                        ))\n                        fig.add_trace(go.Scatter(\n                            x=snr, y=y_values_min,\n                            fill='tonexty', mode='lines+markers',\n                            line=dict(width=2, dash='dash', color=color),\n                            marker=dict(symbol='x', size=6),\n                            name=f"min/max - {alias} - {t}"  \n                        ))\n   \n                    fig.add_trace(go.Scatter(\n                        x=snr, y=y_values,\n                        mode='lines+markers',\n                        line=dict(width=2, color=color),\n                        name=f"{self.lab} - {alias} - {t}"  \n                    ))\n            else :\n                color = next(color_cycle)\n                snr = config_data[noiseKey]\n                y_values = config_data[self.lab]         \n                \n                if show_envelope :\n                    y_values_min = config_data[self.labmin]  \n                    y_values_max = config_data[self.labmax]   \n                    \n                    # Courbe pour la latence avec enveloppe\n                    fig.add_trace(go.Scatter(\n                        x=snr, y=y_values_max,\n                        fill=None, mode='lines+markers',\n                        line=dict(width=2, dash='dash', color=color),\n                        marker=dict(symbol='x', size=6),\n                        showlegend=False\n                    ))\n                    fig.add_trace(go.Scatter(\n                        x=snr, y=y_values_min,\n                        fill='tonexty', mode='lines+markers',\n                        line=dict(width=2, dash='dash', color=color),\n                        marker=dict(symbol='x', size=6),\n                        name=f"min/max - {config}"  \n                    ))\n                \n                fig.add_trace(go.Scatter(\n                    x=snr, y=y_values,\n                    mode='lines+markers',\n                    line=dict(width=2, color=color),\n                    name=f"{self.lab} - {config}"  \n                ))\n        \n        # Configuration de la mise en page avec Range Slider et Range Selector\n        fig.update_layout(\n            title="Latence en fonction du SNR pour chaque configuration",\n            xaxis=dict(\n                title=f"Niveau de Bruit (SNR) : {noiseKey}",\n                rangeslider=dict(visible=True),\n                rangeselector=dict(\n                    buttons=list([\n                        dict(count=1, label="1dB", step="all", stepmode="backward"),\n                        dict(count=5, label="5dB", step="all", stepmode="backward"),\n                        dict(count=10, label="10dB", step="all", stepmode="backward"),\n                        dict(step="all")\n                    ])\n                )\n            ),\n            yaxis=dict(\n                title=self.Ytitle,\n            ),\n            legend_title="Configurations",\n            template="plotly_white",\n            height=600,\n            showlegend=True,\n            margin=dict(t=70, b=50, l=50, r=10)\n        )\n        \n        return  pn.pane.Plotly(fig, sizing_mode="stretch_width")\n\nclass Mutual_information_Panels (pn.viewable.Viewer) :\n    # Param\xe8tres configurables\n    lv2_model = param.ClassSelector(default=None, class_=Lvl2_Filter_Model)\n    noiseScale = param.ClassSelector(default=None, class_=pn.viewable.Viewer,doc="Choix de l'\xe9chelle de bruit par passage du label de la colonne")\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        \n        self.colors = itertools.cycle(px.colors.qualitative.Plotly)\n        \n        df =self.lv2_model.df_runs_filtred\n        cols = ["Mutual Information.MI", "Mutual Information.MI_min", "Mutual Information.MI_max", "Mutual Information.n_trials"]\n        df = df [ df[cols].notnull().any(axis=1) ]\n        \n        self.plot_mutual_information = Panel_graph_envelope(\n            lv2_model = self.lv2_model,\n            df = df,\n            lab   ="Mutual Information.MI", \n            labmin="Mutual Information.MI_min", \n            labmax="Mutual Information.MI_max", \n            Ytitle = "Information mutuelle",\n            noiseScale = self.noiseScale\n        )\n        \n        self.ListBouton = pn.Column(\n            pn.widgets.TooltipIcon(value="Seuls les configuration avec des valeurs pour \\"Mutual Information.MI\\", \\"Mutual Information.MI_min\\", \\"Mutual Information.MI_max\\", \\"Mutual Information.n_trials\\" sont affich\xe9es. "), \n            width=50)\n        self.mutual_information_ntrial = pn.bind(self._plottrial, self.lv2_model.param.value, self.noiseScale.param.value)\n\n    def __panel__(self):\n        return pn.Column(\n            pn.widgets.TooltipIcon(value="Seuls les configuration avec des valeurs pour \\"Mutual Information.MI\\", \\"Mutual Information.MI_min\\", \\"Mutual Information.MI_max\\" sont affich\xe9es. "), \n            pn.Row(self.plot_mutual_information),\n            pn.Row(self.ListBouton, self.mutual_information_ntrial)\n        )\n    \n    def _plottrial(self, index, noiseKey):\n        ''' graphe de Nombre d'essais'''\n        df_filtred = self.lv2_model.df_runs_filtred\n        \n        # Si pas de donn\xe9es de t\xe2ches pour les configurations s\xe9lectionn\xe9es\n        if df_filtred.empty:\n            return pn.pane.Markdown(f"Mutual Information : Pas de donn\xe9es compl\xe8tes d'information mutuelle disponibles pour les configurations s\xe9lectionn\xe9es.")\n\n        # G\xe9n\xe9rer une palette de couleurs automatiquement selon le nombre de configurations\n        fig = go.Figure()\n        \n        # Ajouter une trace pour chaque configuration et t\xe2che\n        for i, config in enumerate(index):\n            # Filtrer les donn\xe9es pour chaque configuration\n            matching_runs = df_filtred.index[df_filtred['Command_id'] == config]\n            config_data = df_filtred.loc[matching_runs]\n            \n            # V\xe9rifier que les colonnes existent et ne sont pas toutes NaN\n            if noiseKey not in config_data.columns or "Mutual Information.n_trials" not in config_data.columns:\n                continue  # Colonnes manquantes\n\n            config_data = config_data.dropna(subset=[noiseKey, "Mutual Information.n_trials"])\n\n            if config_data.empty:\n                continue  # Plus de donn\xe9es apr\xe8s nettoyage\n            \n            snr = config_data[noiseKey]\n            n_trials = config_data["Mutual Information.n_trials"]         \n                \n            fig.add_trace(go.Scatter(\n                x=snr, y=n_trials,\n                mode='markers',\n                line=dict(width=2, color=next(self.colors)),\n                name=f"Nombre d'essais - {config}"  \n            ))\n        \n        if not fig.data:\n            return pn.pane.Markdown(\n                "Mutual Information : Donn\xe9es insuffisantes (valeurs NaN ou colonnes manquantes) pour les configurations s\xe9lectionn\xe9es."\n            )\n                \n        # Configuration de la mise en page avec Range Slider et Range Selector\n        fig.update_layout(\n            title="Nombre d'essais en fonction du SNR pour chaque configuration",\n            xaxis=dict(\n                title=f"Niveau de Bruit (SNR) : {noiseKey}",\n                rangeslider=dict(visible=True),\n                rangeselector=dict(\n                    buttons=list([\n                        dict(count=1, label="1dB", step="all", stepmode="backward"),\n                        dict(count=5, label="5dB", step="all", stepmode="backward"),\n                        dict(count=10, label="10dB", step="all", stepmode="backward"),\n                        dict(step="all")\n                    ])\n                )\n            ),\n            yaxis=dict(\n                title="Nombre d'essais",\n            ),\n            legend_title="Configurations",\n            template="plotly_white",\n            height=600,\n            showlegend=True,\n            margin=dict(t=70, b=50, l=50, r=10)\n        )\n        \n        return  pn.pane.Plotly(fig, sizing_mode="stretch_width")\n\n##################################### Niveau 3 : Commande ####################################\n\n# ------------------------------------------------------------------\n# Gestion des donn\xe9es niveau 3 s\xe9lection unique\n# ------------------------------------------------------------------\n\nclass ConfigUniqueSelector(pn.viewable.Viewer):\n    model = param.ClassSelector(class_=ConfigUniqueModel)\n\n    def __init__(self, **params):\n        super().__init__(**params)\n\n        # RadioBoxGroup initialis\xe9 avec les alias disponibles\n        self.selector = pn.widgets.RadioBoxGroup(\n            name='Configurations',\n            options=self.model.options_alias,\n            value=self.model.alias() if self.model.alias() != '-' else None,\n            inline=False\n        )\n\n        # Lorsque l'utilisateur change la s\xe9lection, on met \xe0 jour self.model.value\n        self.selector.param.watch(self._sync_model_from_selector, 'value')\n\n    def _sync_model_from_selector(self, event):\n        """Binde la s\xe9lection (alias) vers le model.value."""\n        if event.new:\n            self.model.value_by_alias(event.new)\n        else:\n            self.model.value = None\n\n    @param.depends('model.options', watch=True)\n    def _sync_selector_from_model(self, event=None):\n        alias = self.model.alias()\n        opts = self.model.options_alias\n        self.selector.options  = opts\n        # Si l'alias du model n'est pas dans les options, on d\xe9sactive\n        if not alias == '-':\n            self.selector.value = alias\n            self.selector.disabled = False\n        else:\n            self.selector.value = None\n            self.selector.disabled = True\n\n    def __panel__(self):\n        return pn.Column(\n            pn.pane.Markdown("**Configurations :**"),\n            self.selector\n        )\n\n# ------------------------------------------------------------------\n# Affichage des journeaux d'exec\n# ------------------------------------------------------------------\n\nclass LogViewer(pn.viewable.Viewer):\n    unique_conf_model = param.ClassSelector(default=None, class_=ConfigUniqueModel)\n    \n    def __init__(self, **params):\n        super().__init__(**params)\n        \n        self.output_pane = pn.pane.Markdown("S\xe9lectionnez une configuration pour voir les fichiers.")\n        self.radioBoutton = ConfigUniqueSelector(name="One Configuration Selection", model= self.unique_conf_model)\n        \n        self.date_selector = pn.widgets.Select(name="Date d'ex\xe9cution", options=[], visible=False)\n        self.date_selector.param.watch(self._update_log_on_date_change, "value")\n\n    @param.depends('unique_conf_model.value', watch=True)\n    def _update_dates(self, event=None):\n        self.date_selector.options = self.unique_conf_model.options_dates\n        self.date_selector.value = self.unique_conf_model.date\n        self.output_pane.object = self.unique_conf_model.log\n\n        if not self.unique_conf_model.date is None :\n            self.date_selector.visible = True\n        else:\n            self.date_selector.visible = False\n\n    def _update_log_on_date_change(self, event=None):\n        self.unique_conf_model.date = self.date_selector.value\n        self.output_pane.object = self.unique_conf_model.log\n\n    def __panel__(self):\n        # Affichage du s\xe9lecteur et des onglets\n        return pn.Column(\n            self.radioBoutton,\n            self.date_selector,\n            self.output_pane,\n            sizing_mode="stretch_width")\n\n\n# ------------------------------------------------------------------\n# Graphe de t\xe2ches\n# ------------------------------------------------------------------\n\nclass Tasks_Histogramme(pn.viewable.Viewer):\n    # Param\xe8tres configurables\n    df = param.DataFrame(doc="Le dataframe contenant les donn\xe9es")\n    multi_choice_widget = param.ClassSelector(default=None, class_=pn.viewable.Viewer, doc="Widget MultiChoice")\n    noiseScale = param.ClassSelector(default=None, class_=pn.viewable.Viewer,doc="Choix de l'\xe9chelle de bruit par passage du label de la colonne")\n\n    def __init__(self, **params):\n        super().__init__(**params)\n        \n        self.button_time_perc = pn.widgets.Toggle(name='%', value=True)\n        self.button_time_perc.param.watch(self.changeIcon, 'value')\n        self.ListBouton = pn.Column(\n            pn.widgets.TooltipIcon(value="Affichage des temps des t\xe2ches en milli-seconde ou en %."), \n            self.button_time_perc,\n            width=50)\n        self.graphPanel = pn.bind(self._plot_task_data, self.button_time_perc, self.multi_choice_widget.param.value, self.noiseScale.param.value)\n        \n    def changeIcon(self, event) :\n        if event.new : \n            self.button_time_perc.name = '%'\n        else :\n            self.button_time_perc.name = '\u23f1'\n    \n    def __panel__(self):\n        return pn.Row(self.ListBouton, self.graphPanel)\n    \n    def _plot_task_data(self,percent, index, noiseKey):\n        db = pn.state.cache['db']\n        \n        \n        if index is None :\n            df_filtred = self.df\n        else :\n            df_filtred = self.df.loc[index] \n        \n        if df_filtred.empty:\n            self.button_time_perc.disabled=True\n            return pn.pane.Markdown(f"Graphes de T\xe2ches : Pas de donn\xe9es de t\xe2ches disponibles pour les configurations s\xe9lectionn\xe9es.")\n        else : \n            self.button_time_perc.disabled=False\n            \n        if percent :\n            y_label = ('Time', 'Dur\xe9e')\n        else :\n            y_label = ('Perc','Dur\xe9e (%)')\n        \n        # Pivot des donn\xe9es pour que chaque combinaison Config_Hash + Signal Noise Ratio(SNR).Eb/N0(dB) ait des colonnes pour les temps des t\xe2ches\n        pivot_df = df_filtred.pivot_table(\n            values=y_label[0], \n            index=['Config_Hash', noiseKey], \n            columns='Task',\n            aggfunc='sum', \n            fill_value=0\n        )\n\n        # G\xe9n\xe9rer une palette de couleurs automatiquement selon le nombre de configurations\n        colors = px.colors.qualitative.Plotly[:len(index) * len(df_filtred['Task'].unique())]\n\n        # Initialiser la figure Plotly\n        fig = go.Figure()\n        \n        # Ajouter chaque t\xe2che comme une barre empil\xe9e\n        for task in pivot_df.columns:\n            fig.add_trace(go.Bar(\n                x=pivot_df.index.map(lambda x: f"{db['commands'].loc[x[0], 'Config_Alias']} - SNR: {x[1]}"),  # Combinaison Config_Hash + SNR comme \xe9tiquette\n                y=pivot_df[task],\n                name=task\n            ))\n\n        # Configuration de la mise en page\n        fig.update_layout(\n            barmode='stack',\n            title=f"Temps des t\xe2ches par Configuration et Niveau de Bruit  : {noiseKey}",\n            xaxis_title="Configuration et Niveau de Bruit",\n            yaxis_title=y_label[1],\n            xaxis=dict(tickangle=25),  # Rotation des \xe9tiquettes de l'axe x\n            template="plotly_white",\n            height=900,\n            showlegend=True,\n            margin=dict(t=70, b=50, l=50, r=10)\n            \n        )\n        return pn.pane.Plotly(fig, sizing_mode="stretch_width")\n\n# Performance par niveau de bruit pour les configurations s\xe9lectionn\xe9es\ndef plot_performance_metrics_plotly(configs, noiseScale):\n    # Si aucune configuration n'est s\xe9lectionn\xe9e\n    if not configs:\n        return pn.pane.Markdown("Veuillez s\xe9lectionner au moins une configuration pour afficher les performances.")\n    db = pn.state.cache['db']\n    filtered_df_runs = db['runs'][db['runs']["Command_id"].isin(configs)]\n    if filtered_df_runs.empty:\n        return pn.pane.Markdown("Pas de donn\xe9es de performance disponibles pour les configurations s\xe9lectionn\xe9es.")\n    \n    filtered_df_runs = filtered_df_runs.sort_values(by=noiseScale, ascending=True)\n    \n    fig = go.Figure()\n    \n    # G\xe9n\xe9rer une palette de couleurs automatiquement selon le nombre de configurations\n    colors = px.colors.qualitative.Plotly[:len(configs)]  # Choisir des couleurs depuis Plotly, ajust\xe9es \xe0 la taille de configs\n    \n    for i, config in enumerate(configs):\n        config_data = filtered_df_runs.loc[filtered_df_runs["Command_id"] == config]\n        snr = config_data[noiseScale]\n        ber = config_data['Bit Error Rate (BER) and Frame Error Rate (FER).BER']\n        fer = config_data['Bit Error Rate (BER) and Frame Error Rate (FER).FER']\n        \n        # Trace BER (ligne pleine avec marqueurs)\n        fig.add_trace(go.Scatter(\n            x=snr, y=ber, mode='lines+markers', name=f"BER - {config}",\n            line=dict(width=2, color=colors[i]),\n            marker=dict(symbol='circle', size=6)\n        ))\n        \n        # Trace FER (ligne pointill\xe9e avec marqueurs)\n        fig.add_trace(go.Scatter(\n            x=snr, y=fer, mode='lines+markers', name=f"FER - {config}",\n            line=dict(width=2, dash='dash', color=colors[i]),\n            marker=dict(symbol='x', size=6)\n        ))\n    \n    \n    # Configuration de la mise en page avec Range Slider et Range Selector\n    fig.update_layout(\n        title="BER et FER en fonction du SNR pour chaque configuration",\n        xaxis=dict(\n            title=f"Niveau de Bruit (SNR) : {noiseScale}",\n            rangeslider=dict(visible=True),  # Activation du Range Slider\n            rangeselector=dict(\n                buttons=list([\n                    dict(count=1, label="1dB", step="all", stepmode="backward"),\n                    dict(count=5, label="5dB", step="all", stepmode="backward"),\n                    dict(count=10, label="10dB", step="all", stepmode="backward"),\n                    dict(step="all")\n                ])\n            )\n        ),\n        yaxis=dict(\n            title="Taux d'Erreur",\n            type='log'\n        ),\n        legend_title="Configurations",\n        template="plotly_white",\n        height=600,\n        showlegend=True,\n        margin=dict(t=70, b=50, l=50, r=10)\n    )\n    \n    return pn.pane.Plotly(fig, sizing_mode="stretch_width")\n\n# ------------------------------------------------------------------\n# Assemblage du panel git\n# ------------------------------------------------------------------\nclass PanelCommit(pn.viewable.Viewer):\n    \n    command_filter = param.ClassSelector(default=None, class_=CommandFilterModel, doc="Filtre de commandes")\n    git_filter = param.ClassSelector(default=None, class_=GitFilterModel, doc="Filtre Git")\n    \n    def __init__(self, **params):\n        super().__init__(**params)\n        # Initialisation du tableau de commandes\n        self.date_slider    = DateRangeFilter(git_filter=self.git_filter)\n        # Composants construits\n        self.code_selector = CodeSelector(cmd_filter_model=self.command_filter)\n        self.table = FilteredTable(filter_model=self.git_filter)\n        db = pn.state.cache['db']\n        self.indicators = GitIndicators(df_git=db['git'], df_commands=db['commands'], filter_model=self.git_filter)\n        self.perfgraph = PerformanceByCommit(git_filter=self.git_filter, command_filter=self.command_filter)\n        self.research_config_filter = Research_config_filter(command_filter=self.command_filter)\n\n    def __panel__(self):\n        return pn.Column(\n            self.indicators,\n            self.date_slider,\n            self.table,\n            self.code_selector,\n            self.research_config_filter,\n            self.perfgraph,\n            sizing_mode="stretch_width"\n        )\n\n    def update_command_table(self, event=None):\n        self.command_table.value = self.command_filter.get_filtered_df()\n\n# ------------------------------------------------------------------\n# Param\xeatre du site\n# ------------------------------------------------------------------\n\nnoiseScale = NoiseScale(noise_label= noise_label)\n\n# ------------------------------------------------------------------\n# Point d\u2019entr\xe9e unique\n# ------------------------------------------------------------------\n\ndef main():\n    print(ud.unidata_version)\n    load_data_sync()\n    for k, v in pn.state.cache['db'].items():\n        print(f"{k:8s} : {len(v):6d} lignes")\n    template = init_dashboard()\n    template.servable()\n\nif IS_PANEL_CONVERT:\n    # GitHub-Pages (pyodide-worker) \u2192 on charge et on sert\n    main()\n\nelif IS_PYODIDE:\n    # JupyterLite ou autre environnement Pyodide \u2192 onload\n    pn.state.onload(lambda: main())\n\nelse:\n    # Mode local \xab python dashboard_commit.py \xbb\n    load_data_sync()\n    for k, v in pn.state.cache['db'].items():\n        print(f"{k:8s} : {len(v):6d} lignes")\n    dashboard = init_dashboard()\n    dashboard.show(port=35489)\n\nawait write_doc()
  `

  try {
    const [docs_json, render_items, root_ids] = await self.pyodide.runPythonAsync(code)
    self.postMessage({
      type: 'render',
      docs_json: docs_json,
      render_items: render_items,
      root_ids: root_ids
    })
  } catch(e) {
    const traceback = `${e}`
    const tblines = traceback.split('\n')
    self.postMessage({
      type: 'status',
      msg: tblines[tblines.length-2]
    });
    throw e
  }
}

self.onmessage = async (event) => {
  const msg = event.data
  if (msg.type === 'rendered') {
    self.pyodide.runPythonAsync(`
    from panel.io.state import state
    from panel.io.pyodide import _link_docs_worker

    _link_docs_worker(state.curdoc, sendPatch, setter='js')
    `)
  } else if (msg.type === 'patch') {
    self.pyodide.globals.set('patch', msg.patch)
    self.pyodide.runPythonAsync(`
    from panel.io.pyodide import _convert_json_patch
    state.curdoc.apply_json_patch(_convert_json_patch(patch), setter='js')
    `)
    self.postMessage({type: 'idle'})
  } else if (msg.type === 'location') {
    self.pyodide.globals.set('location', msg.location)
    self.pyodide.runPythonAsync(`
    import json
    from panel.io.state import state
    from panel.util import edit_readonly
    if state.location:
        loc_data = json.loads(location)
        with edit_readonly(state.location):
            state.location.param.update({
                k: v for k, v in loc_data.items() if k in state.location.param
            })
    `)
  }
}

startApplication()