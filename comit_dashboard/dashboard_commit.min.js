function sendPatch(e,n,t){self.postMessage({type:"patch",patch:e,buffers:n})}async function startApplication(){console.log("Loading pyodide!"),self.postMessage({type:"status",msg:"Loading pyodide"}),self.pyodide=await loadPyodide(),self.pyodide.globals.set("sendPatch",sendPatch),console.log("Loaded!"),await self.pyodide.loadPackage("micropip");const e=["https://cdn.holoviz.org/panel/wheels/bokeh-3.6.1-py3-none-any.whl","https://cdn.holoviz.org/panel/1.5.3/dist/wheels/panel-1.5.3-py3-none-any.whl","pyodide-http==0.2.1","matplotlib","pandas"];for(const n of e){let e;e=n.endsWith(".whl")?n.split("/").slice(-1)[0].split("-")[0]:n,self.postMessage({type:"status",msg:`Installing ${e}`});try{await self.pyodide.runPythonAsync(`\n        import micropip\n        await micropip.install('${n}');\n      `)}catch(n){console.log(n),self.postMessage({type:"status",msg:`Error while installing ${e}`})}}console.log("Packages loaded!"),self.postMessage({type:"status",msg:"Executing code"});try{const[e,n,t]=await self.pyodide.runPythonAsync('\n  \nimport asyncio\n\nfrom panel.io.pyodide import init_doc, write_doc\n\ninit_doc()\n\nimport pandas as pd\nimport panel as pn\nfrom datetime import datetime\nimport os\nimport sys\nimport argparse\nimport re\nfrom pyodide.http import open_url\nimport matplotlib.pyplot as plt\n\n\n# Initialiser Panel\npn.extension(sizing_mode="stretch_width")  # Adapter la taille des widgets et graphiques à la largeur de l\'écran\n\n##################################### Chargement ####################################\n\n# Charger les données si elles existent\ndef load_data():\n    def csvread(name):\n        path = args.database_path + name + \'.csv\'\n        \n        if os.path.exists(path):\n            # Chargement depuis le chemin local\n            ret = pd.read_csv(path)\n        else:\n            # Gestion de l\'environnement Pyodide\n            if "pyodide" in sys.modules:\n                # Utiliser le lien "raw" de GitHub pour un accès direct\n                url = f"https://raw.githubusercontent.com/fCheminadeInria/aff3ct.github.io/master/comit_dashboard/database/{name}.csv"\n                try:\n                    with open_url(url) as file:\n                        ret = pd.read_csv(file)\n                except Exception as e:\n                    print(f"Echec au chargement de {name} depuis {url} : {e}")\n                    ret = pd.DataFrame()  # Retourne un DataFrame vide en cas d\'échec\n            else:\n                print(f"Echec au chargement de {name} : {path} (fichier introuvable)")\n                ret = pd.DataFrame()  # Retourne un DataFrame vide si le fichier n\'existe pas\n        \n        return ret\n    \n    config_df      = csvread(\'config\')\n    config_df.set_index(\'Config_Hash\', inplace=True)\n    \n    task_df        = csvread(\'tasks\')\n    task_df.set_index(\'Config_Hash\', inplace=True)\n    \n    performance_df = csvread(\'performances\')\n    performance_df.set_index(\'Config_Hash\', inplace=True)\n    \n    git_df         = csvread(\'log_git\')\n    \n    git_df.set_index(\'echo sha\', inplace=True)\n    git_df[\'date\'] = pd.to_datetime(git_df[\'date\'],utc=True) \n    \n    # Créer un dictionnaire de correspondance Config_Hash → Config_Alias\n    config_df[\'Config_Alias\'] = config_df[\'Meta.GitVersion\'] + "_"  +  config_df[\'Meta.Command\'] + "(" + config_df.index + ")"\n    config_aliases = dict(zip(config_df.index, config_df[\'Config_Alias\']))\n    \n    return config_df, task_df, performance_df, git_df, config_aliases\n\n\n# Configurer argparse pour gérer les arguments en ligne de commande\ndef parse_arguments():\n    parser = argparse.ArgumentParser(description="Tableau de bord des commits.")\n    parser.add_argument(\'-l\', \'--local\', action="store_true", help="Local affiche le tableau de bord dans le navigateur, son absence permet son export.")  # on/off flag\n    parser.add_argument(\'--database_path\', default=\'./comit_dashboard/database/\', help="Remplace le chemin par défaut (./comit_dashboard/database/) vers la base de données.")  # on/off flag\n    return parser.parse_args()\n\n # Utiliser des valeurs par défaut dans le cas d\'un export qui ne supporte pas argparse\nclass DefaultArgs:\n    local = False\n    database_path = "./comit_dashboard/database/"\nargs = DefaultArgs()\nif __name__ == "__main__":\n    args = parse_arguments()  # Appel unique de argparse ici\n\n\n\n\n\n\n# Charger les données initiales\nconfig_df, task_df, performance_df, git_df, config_aliases = load_data()\n\n##################################### Données ####################################\n\n# Widgets d\'affichage des informations\nconfig_count = pn.indicators.Number(name="Nombre de configurations", value=config_df.index.nunique() if not config_df.empty else 0)\ngit_version_count = pn.indicators.Number(name="Nombre de versions Git avec des données", value=config_df[\'Meta.GitVersion\'].nunique() if not config_df.empty else 0)\ncommit_count = pn.indicators.Number(name="Nombre de commits historisés dans Git", value=git_df .index.nunique() if not git_df.empty else 0)\n\n# Créer un indicateur pour afficher la date du commit le plus récent\nlatest_commit_date = git_df[\'date\'].max() if not git_df.empty else "Aucune date disponible"\nlatest_commit_date_str = latest_commit_date.strftime(\'%Y-%m-%d %H:%M:%S\') if latest_commit_date != "Aucune date disponible" else latest_commit_date\n\n# Extraire la date du commit le plus récent\nlatest_commit_date = git_df[\'date\'].max() if not git_df.empty else "Aucune date disponible"\n\n# Créer un widget statique pour afficher la date du commit le plus récent\nlatest_commit_date_display = pn.Column(\n        pn.widgets.StaticText(name="Date du dernier commit",css_classes=["tittle_indicator-text"]),\n        pn.widgets.StaticText(value=str(latest_commit_date),css_classes=["indicator-text"])\n)\n\npn.config.raw_css = [\n    """\n    .tittle_indicator-text {\n        font-size: 20px;\n        font-weight: normal;\n        color: #333333;\n    }\n    .indicator-text {\n        font-size: 64px;\n        font-weight: normal;\n        color: #333333;\n    }\n    """\n]\n\n#panel de la partie data\npanelData = pn.Column(config_count, \n                   git_version_count, \n                   commit_count,\n                   latest_commit_date_display,\n        sizing_mode="stretch_width")\n\n##################################### Git ####################################\n\ndef filter_data(git_df, project, date_range):\n    start_date, end_date = date_range\n    # Filtrage par date \n    start_date = datetime.combine(date_range[0], datetime.min.time())\n    end_date   = datetime.combine(date_range[1], datetime.min.time())\n    \n    # Convertir les dates de la colonne \'date\' de git_df en tz-naive\n    git_df[\'date\'] = git_df[\'date\'].dt.tz_localize(None)\n\n    # Filtrage des données en fonction de la plage de dates\n    filtered_df = git_df[(git_df[\'date\'] >= start_date) & (git_df[\'date\'] <= end_date)]   \n    \n    # Filtrage par projet, si ce n\'est pas \'Tous\'\n    if project != \'Tous\':\n        filtered_df = filtered_df[filtered_df[\'Project\'] == project]\n    \n    # Mise à jour de la table avec les données filtrées\n    table_commit.value = filtered_df\n\n# Lier le filtre au slider et au RadioButton\ndef update_filter(event):\n    project = project_radio_button.value\n    date_range = date_range_slider.value\n    filter_data(git_df, project, date_range)\n\n# Radiobouton\n# Extraire les projets uniques de git_df et ajouter "Tous"\nprojects = git_df[\'Project\'].unique().tolist()\nprojects.append(\'Tous\')  # Ajout de l\'option \'Tous\'\n\n# Créer le widget RadioButton\nproject_radio_button = pn.widgets.RadioButtonGroup(\n    name=\'Sélectionner un projet\',\n    options=projects,\n    value=\'Tous\'  # Option par défaut\n)\n\n# Configuration de l\'intervalle de dates pour le DateRangeSlider\nmin_date = git_df[\'date\'].min() if not git_df.empty else datetime(2000, 1, 1)\nmax_date = git_df[\'date\'].max() if not git_df.empty else datetime.now()\n\n# Création du DateRangeSlider\ndate_range_slider = pn.widgets.DateRangeSlider(\n    name="Sélectionnez l\'intervalle de dates",\n    start=min_date,\n    end=max_date,\n    value=(min_date, max_date),\n)\n\n#table de données Git\ntable_commit = pn.widgets.DataFrame(git_df, name=\'Table de Données\', text_align = \'center\')\n\n# Lier les événements aux widgets\nproject_radio_button.param.watch(update_filter, \'value\')\ndate_range_slider.param.watch(update_filter, \'value\')\n\n# Initialisation de la table avec les données filtrées par défaut\nfilter_data(git_df, project_radio_button.value, date_range_slider.value)\n\npanelCommit = pn.Column(\n    pn.Column(project_radio_button, date_range_slider),\n    table_commit\n)\n\n##################################### Config ####################################\n\n# Performance par niveau de bruit pour les configurations sélectionnées\ndef plot_performance_metrics(configs):\n    \n    if not configs:\n        return pn.pane.Markdown("Veuillez sélectionner au moins une configuration pour afficher les performances.")\n    \n    filtered_performance_df = performance_df[performance_df.index.isin(configs)]\n    if filtered_performance_df.empty:\n        return pn.pane.Markdown("Pas de données de performance disponibles pour les configurations sélectionnées.")\n\n    fig, ax = plt.subplots(figsize=(8, 4))\n    for config in configs:\n        config_data = filtered_performance_df[filtered_performance_df.index == config]\n        snr = config_data[\'Noise_Level\']\n        ber = config_data[\'Bit Error Rate (BER) and Frame Error Rate (FER).BER\']\n        fer = config_data[\'Bit Error Rate (BER) and Frame Error Rate (FER).FER\']\n        \n        ax.plot(snr, ber, marker=\'o\', label=f"BER - {config}")\n        ax.plot(snr, fer, marker=\'x\', linestyle=\'--\', label=f"FER - {config}")\n    \n    ax.set_title("BER et FER en fonction du SNR pour chaque configuration")\n    ax.set_xlabel("Niveau de Bruit (SNR)")\n    ax.set_ylabel("Taux d\'Erreur")\n    ax.set_yscale("log")\n    ax.legend()\n    plt.grid(True, which="both", linestyle=\'--\', linewidth=0.5)\n    \n    return pn.pane.Matplotlib(fig, sizing_mode="stretch_width")\n\n# Graphe de valorisation des données de tâches pour les configurations sélectionnées\ndef plot_task_data(configs):\n    \n    if not configs:\n        return pn.pane.Markdown("Veuillez sélectionner au moins une configuration pour afficher les données de tâches.")\n    \n    filtered_task_df = task_df[task_df.index.isin(configs)]\n    if filtered_task_df.empty:\n        return pn.pane.Markdown("Pas de données de tâches disponibles pour les configurations sélectionnées.")\n\n    fig, ax = plt.subplots(figsize=(8, 4))\n    for config in configs:\n        config_data = filtered_task_df[filtered_task_df.index == config]\n        snr = config_data[\'Noise_Level\']\n        call_counts = config_data[\'Calls\']  # Nombre d\'appels pour chaque tâche\n        \n        ax.plot(snr, call_counts, marker=\'o\', label=f"Appels - {config}")\n    \n    ax.set_title("Nombre d\'appels en fonction du SNR pour chaque configuration")\n    ax.set_xlabel("Niveau de Bruit (SNR)")\n    ax.set_ylabel("Nombre d\'Appels")\n    ax.legend()\n    plt.grid(True, which="both", linestyle=\'--\', linewidth=0.5)\n    \n    return pn.pane.Matplotlib(fig, sizing_mode="stretch_width")\n\n# Boutons d\'agrégat\ndef select_all_configs(event=None):\n    config_selector.value = config_options\n\ndef clear_configs(event=None):\n    config_selector.value = []\n\n# Multi-sélecteur de configurations\n#config_options = config_df.index.unique().tolist() if not config_df.empty else []\n#config_options = [config_aliases.get(config, config) for config in config_df.index.unique()]\nconfig_options = [\n        f"{config_aliases.get(config_hash)}"\n        for config_hash in config_df.index.unique()\n    ]\nconfig_options = config_df.index.unique().tolist() if not config_df.empty else []\nconfig_selector = pn.widgets.MultiChoice(name="Sélectionnez les configurations", options=config_options)\n\n# Sélecteur des configs\nselect_all_button = pn.widgets.Button(name="Tout sélectionner", button_type="success")\nclear_button = pn.widgets.Button(name="Tout désélectionner", button_type="warning")\n\nselect_all_button.on_click(select_all_configs)\nclear_button.on_click(clear_configs)\n\n\n# Configuration initiale Tout\nconfig_allowed = {}\nfor col in config_df.columns:\n    config_allowed[col] = config_df[col].unique().tolist()\n\nconfig_filtered = config_df.index\n\n# Fonction de filtrage\ndef filter_config(config_df, config_allowed):\n    # Filtre le DataFrame en fonction des valeurs définies dans config_allowed\n    config_filtered_df = config_df.copy()\n    for col, allowed_values in config_allowed.items():\n        if allowed_values:  # S\'il y a des valeurs autorisées pour cette colonne\n            config_filtered_df = config_filtered_df[config_filtered_df[col].isin(allowed_values)]\n    return config_filtered_df.index\n\n# Callback pour mettre à jour config_allowed et déclencher le filtrage\ndef update_filterconfig(event):\n    config_allowed[event.obj.name] = event.new\n    event.obj.param.disabled = len(event.new) == 1 #A tester\n    config_filtered = filter_config(config_df, config_allowed)\n    config_selector.param.config_options= config_filtered  # Vous pouvez l\'afficher ou le retourner pour un usage ultérieur\n\n\n# Charger config.csv et identifier les familles et leurs colonnes\ndef create_family_widgets(config_df):\n    # Filtrer les colonnes qui suivent le format "FAMILLE.nom"\n    \n    # Les colonnes suivantes ne doivent pas avoir de filtre\n    config_df = config_df.drop(\'Config_Alias\', axis=1)\n    \n    family_columns = {}\n    for col in config_df.columns:\n        match = re.match(r"(\\w+)\\.(\\w+)", col)\n        if match:\n            family, name = match.groups()\n            if family not in family_columns:\n                family_columns[family] = []\n            family_columns[family].append(col)\n        else:\n            # Ajoute les colonnes sans famille dans une clé générale\n            family_columns.setdefault("Autres", []).append(col)\n    \n    # Créer les widgets de sélection pour chaque famille\n    family_widgets = {}\n    for family, columns in family_columns.items():\n        widgets = []\n        for col in columns :\n            options = config_df[col].unique().tolist()\n            is_disabled = len(options) == 1\n            widget = pn.widgets.MultiChoice(name=col, options=options, value=options, disabled=is_disabled, css_classes=["grayed-out"] if is_disabled else [])\n            \n            widget.param.watch(update_filterconfig, \'value\')\n            widgets.append(widget)\n            \n        family_widgets[family] = pn.Column(*widgets, name=family)\n\n    return family_widgets\n\n# Créer les widgets de sélection selon les familles du fichier config.csv\nfamily_widgets = create_family_widgets(config_df)\n\n\n# Ajouter chaque groupe de widgets dans un Accordion pour permettre le repli\naccordion_families = pn.Accordion(*[(f"{family}", widget) for family, widget in family_widgets.items()])\n\ndef build_table_selected_config(config_df):\n    filtered_df = config_df.filter(regex="^(Meta|Simulation)\\.")\n    filtered_df.columns = filtered_df.columns.str.replace(r"^(Meta\\.|Simulation\\.)", "", regex=True)\n    return pn.pane.DataFrame(filtered_df, name=\'table.selected_config\', text_align = \'center\', index=False)\n\ntable_selected_config = build_table_selected_config(config_df)\n\nconfig_accordion_data = pn.Accordion(\n    ("Selected Configuration", table_selected_config)\n)\n\ndef table_selected_config_filter(configs):\n    filtered_df  = config_df.loc[configs].filter(regex="^(Meta|Simulation)\\.")\n    filtered_df.columns = filtered_df.columns.str.replace(r"^(Meta\\.|Simulation\\.)", "", regex=True)\n    table_selected_config.object = filtered_df\n\n# panel des configs\npanelConfig = pn.Row(\n    pn.Column(select_all_button, clear_button, config_selector, accordion_families, width=300),\n    pn.Column(\n        config_accordion_data,\n        #table_selected_config,\n        pn.bind(plot_performance_metrics, config_selector),\n        pn.bind(plot_task_data, config_selector),\n        pn.bind(table_selected_config_filter,config_selector),\n        sizing_mode="stretch_width"\n    )\n)\n\n##################################### Tableau de bord ####################################\n\n# Panneaux repliables sur les données\n\n\n# Layout du tableau de bord avec tout dans une colonne et des arrières-plans différents\ndashboard = pn.Column(\n    pn.pane.HTML("<div style=\'font-size: 28px;background-color: #e0e0e0; padding: 10px;line-height : 0px;\'><h2>Statistiques des Commits</h2></div>"),\n    panelCommit,\n    pn.pane.HTML("<div style=\'font-size: 28px;background-color: #e0e0e0; padding: 10px;line-height : 0px;\'><h2>Courbes et Graphiques</h2></div>"),\n    panelConfig\n)\n\nACCENT = "teal"\n\nstyles = {\n    "box-shadow": "rgba(50, 50, 93, 0.25) 0px 6px 12px -2px, rgba(0, 0, 0, 0.3) 0px 3px 7px -3px",\n    "border-radius": "4px",\n    "padding": "10px",\n  }\n\ndashboard= pn.template.FastListTemplate(\n    title="Commits Dashboard",\n    sidebar=[panelData],\n    main=[dashboard],\n    main_layout=None,\n    accent=ACCENT,\n    theme_toggle=False,\n)\n\n\n# Lancer le tableau de bord\nif args.local :\n    dashboard.show()\nelse :\n    dashboard.servable()\n\n\n\n\n\n\n\n\n\n\n\nawait write_doc()\n  ');self.postMessage({type:"render",docs_json:e,render_items:n,root_ids:t})}catch(e){const n=`${e}`.split("\n");throw self.postMessage({type:"status",msg:n[n.length-2]}),e}}importScripts("https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js"),self.onmessage=async e=>{const n=e.data;"rendered"===n.type?self.pyodide.runPythonAsync("\n    from panel.io.state import state\n    from panel.io.pyodide import _link_docs_worker\n\n    _link_docs_worker(state.curdoc, sendPatch, setter='js')\n    "):"patch"===n.type?(self.pyodide.globals.set("patch",n.patch),self.pyodide.runPythonAsync("\n    from panel.io.pyodide import _convert_json_patch\n    state.curdoc.apply_json_patch(_convert_json_patch(patch), setter='js')\n    "),self.postMessage({type:"idle"})):"location"===n.type&&(self.pyodide.globals.set("location",n.location),self.pyodide.runPythonAsync("\n    import json\n    from panel.io.state import state\n    from panel.util import edit_readonly\n    if state.location:\n        loc_data = json.loads(location)\n        with edit_readonly(state.location):\n            state.location.param.update({\n                k: v for k, v in loc_data.items() if k in state.location.param\n            })\n    "))},startApplication();